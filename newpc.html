<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•è¯è·‘é…·</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #1e3a8a; /* æ·±è“è‰²å›ºå®šèƒŒæ™¯ */
        }
        #gameCanvas {
            display: block;
            margin: 0 auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
        }
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #controls {
            position: absolute;
            bottom: 80px;
            left: 20px;
            z-index: 10;
            display: none;
        }
        #joystick {
            width: 150px;
            height: 150px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: relative;
        }
        #joystickKnob {
            width: 50px;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #jumpButton {
            position: absolute;
            bottom: 80px;
            right: 30px;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: white;
            z-index: 10;
            display: none;
        }
        #startScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
        }
        #startScreen h1 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            width: 100%;
            text-align: center;
        }
        #startScreen p {
            color: white;
            margin-bottom: 20px;
            font-size: 18px;
            text-align: center;
            width: 100%;
        }
        .button {
            padding: 15px 30px;
            background-color: #22c55e;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            text-align: center;
        }
        .button:hover {
            background-color: #16a34a;
            transform: translateY(-2px);
        }
        .button:active {
            transform: translateY(1px);
        }
        #fileInput {
            display: none;
        }
        #characterSelect {
            margin-top: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 500px;
        }
        #characterSelect p {
            text-align: center;
            width: 100%;
        }
        .characterOption {
            display: flex;
            margin: 15px;
            justify-content: center;
            width: 100%;
        }
        .characterButton {
            width: 80px;
            height: 100px;
            margin: 0 15px;
            cursor: pointer;
            border: 3px solid transparent;
            padding: 10px;
            border-radius: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .characterButton p {
            margin-top: 5px;
            margin-bottom: 0;
            text-align: center;
            width: 100%;
        }
        .characterButton:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .characterButton.selected {
            border-color: #f59e0b;
            background-color: rgba(245, 158, 11, 0.3);
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
        }
        #volumeIcon {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 20;
            display: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }
        #volumeIcon:hover {
            transform: scale(1.1);
        }
        #hintButton {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 20;
            display: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }
        #hintButton:hover {
            transform: scale(1.1);
        }
        #pauseButton {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }
        #pauseButton:hover {
            transform: scale(1.1);
        }
        #studyModeToggle {
            position: absolute;
            top: 20px;
            right: 70px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            font-weight: bold;
        }
        #studyModeToggle.active {
            background-color: #22c55e;
            color: white;
        }
        #pauseMenu {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(30, 58, 138, 0.9) 0%, rgba(59, 130, 246, 0.9) 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 110;
        }
        #pauseMenu h2 {
            color: white;
            font-size: 36px;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            text-align: center;
            width: 100%;
        }
        #progressBar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #progressFill {
            height: 100%;
            background-color: #22c55e;
            width: 0%;
            transition: width 0.3s;
        }
        #score {
            position: absolute;
            top: 50px;
            left: 20px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        #loading {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(30, 58, 138, 0.95) 0%, rgba(59, 130, 246, 0.95) 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 120;
            color: white;
        }
        #loading h2 {
            font-size: 30px;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        #loadingBar {
            width: 300px;
            height: 30px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            margin-top: 20px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #loadingFill {
            height: 100%;
            width: 0%;
            background-color: #22c55e;
            transition: width 0.3s;
        }
        #wordArchive {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            display: none;
            padding: 15px;
            height: 180px;
            z-index: 20;
        }
        #wordArchiveTitle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        #wordArchiveTitle h3 {
            margin: 0;
        }
        #exportButton {
            background-color: #22c55e;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }
        #archivedWordsList {
            max-height: 120px;
            overflow-y: auto;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        .archiveWord {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        .archiveWord div {
            margin-right: 10px;
            flex: 1;
        }
        .hintCount {
            flex: 0 0 80px !important;
            text-align: center;
        }
        .season-button {
            position: absolute;
            top: 20px;
            right: 180px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            font-weight: bold;
        }
        #hintedWordsButton {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 8px 15px;
            border-radius: 8px;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            font-weight: bold;
        }
        #hintedWordsButton.active {
            background-color: #22c55e;
            color: white;
        }
        #rainbow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 3s;
        }
        
        /* ç§»åŠ¨è®¾å¤‡é€‚é…ä¼˜åŒ– */
        @media (max-width: 768px) {
            #pauseButton, #studyModeToggle, .season-button {
                width: 36px;
                height: 36px;
                padding: 3px 8px;
                font-size: 12px;
            }
            
            #progressBar {
                width: 140px;
            }
            
            #score {
                font-size: 14px;
            }
            
            .characterOption {
                flex-wrap: wrap;
            }
            
            #controls {
                bottom: 100px;
            }
            
            #jumpButton {
                bottom: 100px;
                right: 20px;
            }
            
            #hintedWordsButton {
                font-size: 12px;
                padding: 6px 12px;
            }
        }
        
        /* é’ˆå¯¹æ¨ªå±æ¨¡å¼ä¼˜åŒ– */
        @media (max-height: 500px) and (orientation: landscape) {
            #pauseButton, #studyModeToggle, .season-button {
                top: 10px;
            }
            
            #progressBar {
                top: 10px;
                height: 15px;
            }
            
            #score {
                top: 30px;
            }
            
            #controls {
                bottom: 20px;
                transform: scale(0.7);
                transform-origin: bottom left;
            }
            
            #jumpButton {
                bottom: 20px;
                right: 20px;
                transform: scale(0.7);
                transform-origin: bottom right;
            }
            
            #hintedWordsButton {
                bottom: 10px;
            }
            
            #wordArchive {
                height: 120px;
            }
            
            #archivedWordsList {
                max-height: 80px;
            }
        }
        
        /* å¢å¼ºçš„æ¨ªå±é€‚é… */
        @media (orientation: landscape) {
            #gameCanvas {
                width: 100%;
                height: 100vh;
                margin: 0;
            }
            
            #gameContainer {
                width: 100vw;
                height: 100vh;
                overflow: hidden;
            }
        }

        #tutorialScreen {
    position: absolute;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, rgba(30, 58, 138, 0.97) 0%, rgba(59, 130, 246, 0.97) 100%);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 150;
    overflow-y: auto;
}

#tutorialContent {
    width: 90%;
    max-width: 800px;
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 15px;
    padding: 30px;
    color: white;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    max-height: 90vh;
    overflow-y: auto;
}

#tutorialContent h2 {
    font-size: 32px;
    text-align: center;
    margin-bottom: 30px;
    color: white;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
}

.tutorial-section {
    margin-bottom: 30px;
    padding-bottom: 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

.tutorial-section h3 {
    font-size: 24px;
    color: #22c55e;
    margin-bottom: 15px;
}

.tutorial-section p {
    font-size: 16px;
    line-height: 1.6;
    margin-bottom: 15px;
}

.tutorial-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    background-color: rgba(0, 0, 0, 0.2);
    border-radius: 8px;
    overflow: hidden;
}

.tutorial-table th, .tutorial-table td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.tutorial-table th {
    background-color: rgba(0, 0, 0, 0.3);
    color: #22c55e;
}

.character-showcase, .interaction-showcase {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 20px;
    margin-top: 20px;
}

.character-item, .interaction-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: rgba(0, 0, 0, 0.2);
    padding: 15px;
    border-radius: 10px;
    width: 120px;
}

.character-item p, .interaction-item p {
    margin-top: 10px;
    margin-bottom: 0;
    text-align: center;
}

.interaction-item {
    width: 150px;
}

.tutorial-section ul {
    list-style-type: none;
    padding-left: 0;
}
.tutorial-section ul li {
    padding: 8px 0;
    position: relative;
    padding-left: 25px;
}

.tutorial-section ul li:before {
    content: "â€¢";
    color: #22c55e;
    font-size: 24px;
    position: absolute;
    left: 5px;
    top: 4px;
}

#closeTutorial {
    display: block;
    margin: 30px auto 10px;
    padding: 15px 30px;
    background-color: #22c55e;
    border: none;
    border-radius: 8px;
    color: white;
    font-size: 18px;
    cursor: pointer;
    transition: all 0.3s;
}

#closeTutorial:hover {
    background-color: #16a34a;
    transform: translateY(-2px);
}

/* ç§»åŠ¨è®¾å¤‡é€‚é… */
@media (max-width: 768px) {
    #tutorialContent {
        padding: 20px;
    }
    
    #tutorialContent h2 {
        font-size: 24px;
    }
    
    .tutorial-section h3 {
        font-size: 20px;
    }
    
    .character-item, .interaction-item {
        width: 100px;
        padding: 10px;
    }
}
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="controls">
            <div id="joystick">
                <div id="joystickKnob"></div>
            </div>
        </div>
        
        <div id="jumpButton">è·³è·ƒ</div>
        
        <div id="volumeIcon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M11 5L6 9H2V15H6L11 19V5Z" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M15.54 8.46C16.4774 9.39764 17.004 10.6692 17.004 12C17.004 13.3308 16.4774 14.6024 15.54 15.54" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M19.07 4.93C20.9447 6.80528 21.9979 9.34836 21.9979 12C21.9979 14.6516 20.9447 17.1947 19.07 19.07" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </div>
        
        <div id="hintButton">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="12" r="10" stroke="black" stroke-width="2"/>
                <path d="M12 7V14" stroke="black" stroke-width="2" stroke-linecap="round"/>
                <circle cx="12" cy="17" r="1" fill="black"/>
            </svg>
        </div>
        
        <div id="pauseButton">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="6" y="4" width="4" height="16" rx="1" fill="black"/>
                <rect x="14" y="4" width="4" height="16" rx="1" fill="black"/>
            </svg>
        </div>
        
        <div id="studyModeToggle">
            èƒŒè¯µæ¨¡å¼ï¼šå…³
        </div>
        
        <div class="season-button" id="seasonToggle">
            å››å­£ï¼šæ˜¥å­£
        </div>
        
        <div id="progressBar">
            <div id="progressFill"></div>
        </div>
        
        <div id="score">å•è¯: 0 / 0</div>
        
        <div id="startScreen">
            <h1>å•è¯è·‘é…·</h1>
            <p>å¯¼å…¥å•è¯è¡¨å¼€å§‹æ¸¸æˆå¹¶é€‰æ‹©è§’è‰²</p>
            <p>è¡¨æ ¼ç¤ºä¾‹ï¼š1ï¸âƒ£è‹±æ–‡ 2ï¸âƒ£ä¸­æ–‡ 3ï¸âƒ£è¯æ€§</p>
            <label for="fileInput" class="button">å¯¼å…¥å•è¯è¡¨ (Excel/CSV/Numbers)</label>
            <input type="file" id="fileInput" accept=".csv,.xlsx,.xls">
            
            <div id="characterSelect">
                <p style="color: white; margin-bottom: 15px; font-size: 20px;">é€‰æ‹©è§’è‰²:</p>
                <div class="characterOption">
                    <div class="characterButton selected" data-character="stickman">
                        <svg width="60" height="80" viewBox="0 0 50 70" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="25" cy="10" r="8" stroke="white" stroke-width="3"/>
                            <line x1="25" y1="18" x2="25" y2="40" stroke="white" stroke-width="3"/>
                            <line x1="25" y1="40" x2="15" y2="60" stroke="white" stroke-width="3"/>
                            <line x1="25" y1="40" x2="35" y2="60" stroke="white" stroke-width="3"/>
                            <line x1="25" y1="30" x2="10" y2="20" stroke="white" stroke-width="3"/>
                            <line x1="25" y1="30" x2="40" y2="20" stroke="white" stroke-width="3"/>
                        </svg>
                        <p>ç«æŸ´äºº</p>
                    </div>
                    <div class="characterButton" data-character="ninja">
                        <svg width="60" height="80" viewBox="0 0 50 70" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="25" cy="10" r="8" stroke="#4CAF50" stroke-width="3"/>
                            <line x1="25" y1="18" x2="25" y2="40" stroke="#4CAF50" stroke-width="3"/>
                            <line x1="25" y1="40" x2="15" y2="60" stroke="#4CAF50" stroke-width="3"/>
                            <line x1="25" y1="40" x2="35" y2="60" stroke="#4CAF50" stroke-width="3"/>
                            <line x1="25" y1="30" x2="10" y2="20" stroke="#4CAF50" stroke-width="3"/>
                            <line x1="25" y1="30" x2="40" y2="20" stroke="#4CAF50" stroke-width="3"/>
                            <path d="M15 10 H35" stroke="#4CAF50" stroke-width="3"/>
                        </svg>
                        <p>å¿è€…</p>
                    </div>
                    <div class="characterButton" data-character="robot">
                        <svg width="60" height="80" viewBox="0 0 50 70" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <rect x="15" y="5" width="20" height="15" rx="2" stroke="#f472b6" stroke-width="3"/>
                            <rect x="10" y="20" width="30" height="25" rx="2" stroke="#f472b6" stroke-width="3"/>
                            <line x1="20" y1="45" x2="20" y2="65" stroke="#f472b6" stroke-width="3"/>
                            <line x1="30" y1="45" x2="30" y2="65" stroke="#f472b6" stroke-width="3"/>
                            <circle cx="20" cy="12" r="3" fill="#f472b6"/>
                            <circle cx="30" cy="12" r="3" fill="#f472b6"/>
                            <line x1="18" y1="30" x2="32" y2="30" stroke="#f472b6" stroke-width="3"/>
                        </svg>
                        <p>æœºå™¨äºº</p>
                    </div>
                </div>
            </div>
            <button id="tutorialButton" class="button">æ–°æ‰‹æŒ‡å—</button>
            <button id="startButton" class="button">å¼€å§‹æ¸¸æˆ</button>
        </div>
        
        <div id="pauseMenu">
            <h2>æ¸¸æˆæš‚åœ</h2>
            <button id="resumeButton" class="button">ç»§ç»­æ¸¸æˆ</button>
            <button id="restartButton" class="button">é‡æ–°å¼€å§‹</button>
            <button id="returnButton" class="button">è¿”å›ä¸»ç•Œé¢</button>
        </div>
        
        <div id="loading">
            <h2>åŠ è½½ä¸­...</h2>
            <div id="loadingBar">
                <div id="loadingFill"></div>
            </div>
        </div>
        
        <div id="wordArchive">
            <div id="wordArchiveTitle">
                <h3>å·²æç¤ºå•è¯</h3>
                <button id="exportButton">å¯¼å‡ºExcel</button>
            </div>
            <div id="archivedWordsList">
                <!-- è¿™é‡Œå°†é€šè¿‡JavaScriptåŠ¨æ€æ·»åŠ æç¤ºè¿‡çš„å•è¯ -->
            </div>
        </div>
        
        <div id="hintedWordsButton">å·²æç¤ºå•è¯</div>
        
        <div id="rainbow"></div>
        <div id="tutorialScreen" style="display: none;">
            <div id="tutorialContent">
                <h2>æ–°æ‰‹æŒ‡å—</h2>
                <div class="tutorial-section">
                    <h3>æ¸¸æˆç›®çš„</h3>
                    <p>æœ¬é¡¹ç›®ä¸ºè·‘é…·èƒŒå•è¯ï¼Œæ—¨åœ¨å¸®åŠ©ç”¨æˆ·è½»æ¾è®°å¿†å•è¯ğŸ˜‰</p>
                </div>
                
                <div class="tutorial-section">
                    <h3>å•è¯è¡¨å¯¼å…¥è¯´æ˜</h3>
                    <p>å•è¯çš„ä¸­æ–‡æˆ–è€…è‹±æ–‡ä¼šéšæœºå‡ºç°åœ¨ç‰©å“ä¸Š</p>
                    <table class="tutorial-table">
                        <tr>
                            <th></th>
            <th>è‹±æ–‡</th>
            <th>ä¸­æ–‡</th>
            <th>è¯æ€§</th>
        </tr>
        <tr>
            <td>ç¤ºä¾‹</td>
            <td>apple</td>
            <td>è‹¹æœ ğŸ</td>
            <td>n</td>
        </tr>
    </table>
</div>
                
                <div class="tutorial-section">
                    <h3>è§’è‰²é€‰æ‹©</h3>
                    <div class="character-showcase">
                        <div class="character-item">
                            <svg width="60" height="80" viewBox="0 0 50 70" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="25" cy="10" r="8" stroke="white" stroke-width="3"/>
                                <line x1="25" y1="18" x2="25" y2="40" stroke="white" stroke-width="3"/>
                                <line x1="25" y1="40" x2="15" y2="60" stroke="white" stroke-width="3"/>
                                <line x1="25" y1="40" x2="35" y2="60" stroke="white" stroke-width="3"/>
                                <line x1="25" y1="30" x2="10" y2="20" stroke="white" stroke-width="3"/>
                                <line x1="25" y1="30" x2="40" y2="20" stroke="white" stroke-width="3"/>
                            </svg>
                            <p>ç«æŸ´äºº</p>
                        </div>
                        <div class="character-item">
                            <svg width="60" height="80" viewBox="0 0 50 70" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="25" cy="10" r="8" stroke="#4CAF50" stroke-width="3"/>
                                <line x1="25" y1="18" x2="25" y2="40" stroke="#4CAF50" stroke-width="3"/>
                                <line x1="25" y1="40" x2="15" y2="60" stroke="#4CAF50" stroke-width="3"/>
                                <line x1="25" y1="40" x2="35" y2="60" stroke="#4CAF50" stroke-width="3"/>
                                <line x1="25" y1="30" x2="10" y2="20" stroke="#4CAF50" stroke-width="3"/>
                                <line x1="25" y1="30" x2="40" y2="20" stroke="#4CAF50" stroke-width="3"/>
                                <path d="M15 10 H35" stroke="#4CAF50" stroke-width="3"/>
                            </svg>
                            <p>å¿è€…</p>
                        </div>
                        <div class="character-item">
                            <svg width="60" height="80" viewBox="0 0 50 70" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <rect x="15" y="5" width="20" height="15" rx="2" stroke="#f472b6" stroke-width="3"/>
                                <rect x="10" y="20" width="30" height="25" rx="2" stroke="#f472b6" stroke-width="3"/>
                                <line x1="20" y1="45" x2="20" y2="65" stroke="#f472b6" stroke-width="3"/>
                                <line x1="30" y1="45" x2="30" y2="65" stroke="#f472b6" stroke-width="3"/>
                                <circle cx="20" cy="12" r="3" fill="#f472b6"/>
                                <circle cx="30" cy="12" r="3" fill="#f472b6"/>
                                <line x1="18" y1="30" x2="32" y2="30" stroke="#f472b6" stroke-width="3"/>
                            </svg>
                            <p>æœºå™¨äºº</p>
                        </div>
                    </div>
                </div>
                
                <div class="tutorial-section">
                    <h3>æ¸¸æˆåŠŸèƒ½</h3>
                    <ul>
                        <li>ç‚¹å‡»ã€èƒŒè¯µæ¨¡å¼ã€‘åç»è¿‡ç‰©ä½“å°†ä¸å†æç¤ºå•è¯è¯»éŸ³åŠé‡Šä¹‰ï¼Œç‚¹å‡»æç¤ºç¬¦å·åæ–¹å¯æŸ¥çœ‹</li>
                        <li>æç¤ºåçš„å•è¯ä¼šè®°å½•ï¼Œå¯ä»¥åœ¨é¡µé¢åº•éƒ¨æŸ¥çœ‹å¹¶å¯¼å‡ºï¼Œæ–¹ä¾¿é‡å¤è®°å¿†</li>
                        <li>æ¸¸æˆå¯ä»¥åˆ‡æ¢å››å­£ï¼Œå¹¶ä¼´éšç™½æ˜¼åˆ‡æ¢</li>
                    </ul>
                </div>
                
                <div class="tutorial-section">
                    <h3>æ¸¸æˆäº¤äº’</h3>
                    <div class="interaction-showcase">
                        <div class="interaction-item">
                            <svg width="80" height="100" viewBox="0 0 60 100">
                                <!-- è—¤è”“ -->
                                <path d="M30,10 Q20,30 30,50 Q40,70 30,90" stroke="#8BC34A" stroke-width="3" fill="none"/>
                                <path d="M30,30 Q40,35 50,30" stroke="#8BC34A" stroke-width="2" fill="none"/>
                                <path d="M30,50 Q20,55 10,50" stroke="#8BC34A" stroke-width="2" fill="none"/>
                                <path d="M30,70 Q40,75 50,70" stroke="#8BC34A" stroke-width="2" fill="none"/>
                            </svg>
                            <p>è—¤è”“å¯æ”€çˆ¬</p>
                        </div>
                        <div class="interaction-item">
                            <svg width="80" height="100" viewBox="0 0 60 100">
                                <!-- æ¢¯å­ -->
                                <line x1="15" y1="10" x2="15" y2="90" stroke="#8D6E63" stroke-width="3"/>
                                <line x1="45" y1="10" x2="45" y2="90" stroke="#8D6E63" stroke-width="3"/>
                                <line x1="15" y1="20" x2="45" y2="20" stroke="#8D6E63" stroke-width="2"/>
                                <line x1="15" y1="40" x2="45" y2="40" stroke="#8D6E63" stroke-width="2"/>
                                <line x1="15" y1="60" x2="45" y2="60" stroke="#8D6E63" stroke-width="2"/>
                                <line x1="15" y1="80" x2="45" y2="80" stroke="#8D6E63" stroke-width="2"/>
                            </svg>
                            <p>æ¢¯å­å¯æ”€çˆ¬</p>
                        </div>
                        <div class="interaction-item">
                            <svg width="80" height="100" viewBox="0 0 60 100">
                                <!-- æ¸¸æˆä¸­çš„èƒèŸ¹æ ·å¼ -->
                                <ellipse cx="30" cy="50" rx="15" ry="10" fill="#e63946" />
                                <!-- çœ¼ç› -->
                                <circle cx="38" cy="45" r="4" fill="white"/>
                               <circle cx="45" cy="45" r="4" fill="white"/>
                               <circle cx="38" cy="45" r="2" fill="black"/>
                               <circle cx="45" cy="45" r="2" fill="black"/>
                                
                               <!-- é’³å­ -->
        <path d="M15,45 A8,8 0 1,0 15,55" stroke="#e63946" stroke-width="3" fill="none"/>
        
        <!-- è…¿ -->
        <line x1="25" y1="55" x2="20" y2="65" stroke="#e76f51" stroke-width="2"/>
        <line x1="30" y1="55" x2="25" y2="65" stroke="#e76f51" stroke-width="2"/>
        <line x1="35" y1="55" x2="40" y2="65" stroke="#e76f51" stroke-width="2"/>
        <line x1="40" y1="55" x2="50" y2="65" stroke="#e76f51" stroke-width="2"/>
                            </svg>
                        
                            <p>ç¢°åˆ°èƒèŸ¹ä¼šè¢«æ¨èµ°</p>
                        </div>
                        <div class="interaction-item">
                            <svg width="80" height="100" viewBox="0 0 60 100">
                                <!-- è†æ£˜ -->
                                <rect x="10" y="70" width="40" height="10" fill="#3a5a40"/>
                                <path d="M15,70 L10,50 L20,70" fill="#a61e4d"/>
                                <path d="M25,70 L20,45 L30,70" fill="#a61e4d"/>
                                <path d="M35,70 L30,50 L40,70" fill="#a61e4d"/>
                                <path d="M45,70 L40,45 L50,70" fill="#a61e4d"/>
                            </svg>
                            <p>ç¢°åˆ°è†æ£˜ä¼šè¢«å¼¹å¼€</p>
                        </div>
                    </div>
                </div>
                
                <button id="closeTutorial" class="button">å¼€å§‹æ¸¸æˆ</button>
            </div>
        </div>

    </div>

    <!-- ä½¿ç”¨Papa Parseå¤„ç†CSVæ–‡ä»¶ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <!-- ä½¿ç”¨SheetJSå¤„ç†Excelæ–‡ä»¶ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        // æ¸¸æˆä¸»è¦å˜é‡
        let canvas, ctx;
        let gameWidth, gameHeight;
        let gameRunning = false;
        let gameStarted = false;
        let gamePaused = false;
        let isMobile = false;
        let wordList = []; // å¯¼å…¥çš„å•è¯åˆ—è¡¨
        let currentWordIndex = 0; // å½“å‰æœ€è¿œçš„è¿›åº¦
        let visibleWordIndex = 0; // å½“å‰çœ‹åˆ°çš„å•è¯ç´¢å¼•ï¼ˆå¯èƒ½å›é€€ï¼‰
        let score = 0; // å¾—åˆ†
        
        // èƒŒè¯µæ¨¡å¼å˜é‡
        let studyMode = false;
        let hintedWords = []; // æç¤ºè¿‡çš„å•è¯åˆ—è¡¨
        let wordArchiveVisible = false; // æ§åˆ¶å•è¯æ¡£æ¡ˆæ˜¯å¦å¯è§
        
        // å­£èŠ‚å’Œå¤©æ°”å˜é‡
        let currentSeason = 'spring'; // spring, summer, autumn, winter
        let seasonTransition = 0; // å­£èŠ‚è¿‡æ¸¡è¿›åº¦ 0-1
        let nextSeason = 'spring';
        let seasonChangeStarted = false;
        
        // è·³æ¿å˜é‡
        let jumpboards = [];
        
        // è§’è‰²é€‰æ‹©
        let selectedCharacter = 'stickman';
        
        // ç©å®¶å˜é‡
        const player = {
            x: 100,
            y: 0,
            width: 40,  // å¢åŠ å®½åº¦
            height: 70, // å¢åŠ é«˜åº¦
            speed: 5,
            jumpForce: 15,
            velY: 0,
            isJumping: false,
            isMovingLeft: false,
            isMovingRight: false,
            frame: 0,
            frameCount: 0,
            color: 'white',
            outlineColor: 'black', // æ·»åŠ è½®å»“é¢œè‰²
            outlineWidth: 4        // è½®å»“ç²—ç»†
        };
        
        // æ§åˆ¶å˜é‡
        let keys = {};
        let joystickActive = false;
        let joystickAngle = 0;
        let joystickDistance = 0;
        
        // æ¸¸æˆå¯¹è±¡
        const gameObjects = [];
        const platforms = [];
        let activeVolumeIcon = null;
        let activeHintButton = null;
        
        // æ¸¸æˆèƒŒæ™¯
        const backgrounds = [];
        
        // æ¸¸æˆæ—¶é—´å’ŒåŠ¨ç”»
        let lastTime = 0;
        let gameTime = 0;
        let animationId;
        
        // æ¸¸æˆç›¸æœº
        const camera = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            leftEdge: function() { return this.x + (this.width * 0.25); },
            rightEdge: function() { return this.x + (this.width * 0.75); },
            topEdge: function() { return this.y + (this.height * 0.25); },
            bottomEdge: function() { return this.y + (this.height * 0.75); }
        };
        
        // å­£èŠ‚é¢œè‰²é…ç½®
        const seasonColors = {
            spring: {
                skyTop: '#87CEEB', // å¤©è“è‰²
                skyBottom: '#E0F7FA', // æ·¡è“è‰²
                ground: '#4CAF50', // ç»¿è‰²
                trees: '#8BC34A', // æµ…ç»¿è‰²
                flowers: ['#FF4081', '#E91E63', '#9C27B0', '#FFEB3B'] // ç²‰çº¢ã€ç´«è‰²ç­‰æ˜¥èŠ±é¢œè‰²
            },
            summer: {
                skyTop: '#1976D2', // æ·±è“è‰²
                skyBottom: '#42A5F5', // äº®è“è‰²
                ground: '#388E3C', // æ·±ç»¿è‰²
                trees: '#43A047', // ä¸­ç»¿è‰²
                flowers: ['#F44336', '#FF9800', '#FFEB3B', '#4CAF50'] // çº¢ã€æ©™ã€é»„ç­‰å¤å­£é¢œè‰²
            },
            autumn: {
                skyTop: '#5D4037', // æ£•è‰²
                skyBottom: '#8D6E63', // æµ…æ£•è‰²
                ground: '#795548', // æ£•è‰²
                trees: '#FF9800', // æ©™è‰²
                flowers: ['#FF5722', '#FF9800', '#FFC107', '#795548'] // æ©™ã€é»„ã€æ£•ç­‰ç§‹å­£é¢œè‰²
            },
            winter: {
                skyTop: '#546E7A', // æ·±ç°è“è‰²
                skyBottom: '#78909C', // æµ…ç°è“è‰²
                ground: '#ECEFF1', // æµ…ç°è‰²ï¼ˆé›ªï¼‰
                trees: '#B0BEC5', // ç°è‰²
                flowers: ['#B3E5FC', '#E1F5FE', '#FFFFFF', '#CFD8DC'] // æµ…è“ã€ç™½è‰²ç­‰å†¬å­£é¢œè‰²
            }
        };
        
        // å¤©æ°”æ•ˆæœå˜é‡
        const weatherEffects = {
            lightning: {
                active: false,
                lastFlash: 0,
                nextFlash: 0,
                opacity: 0
            },
            sandstorm: {
                active: false,
                particles: [],
                intensity: 0
            },
            rainbow: {
                active: false,
                opacity: 0
            }
        };
        
        // é¸Ÿç±»æ•°ç»„
        const birds = [];
        // é¸­å­æ•°ç»„
        const ducks = [];
         // é±¼ç±»æ•°ç»„ - æ›¿ä»£é¸­å­
         const fishes = [];
        // æ± å¡˜æ•°ç»„

        // æ± å¡˜æ•°ç»„
        const ponds = [];
        
        // æ¸¸æˆåˆå§‹åŒ–
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                document.getElementById('controls').style.display = 'block';
                document.getElementById('jumpButton').style.display = 'flex';
                setupJoystick();
                setupJumpButton();
            } else {
                setupKeyboardControls();
            }
            
            setupCharacterSelection();
            setupFileInput();
            setupStartButton();
            setupTutorialButton();
            setupPauseButton();
            setupStudyModeToggle();
            setupSeasonToggle();
            setupWordArchive();
            setupHintedWordsButton();
            setupRainbowElement();
            
            // åˆå§‹åŠ è½½
            document.getElementById('loading').style.display = 'flex';
            let loadingProgress = 0;
            const loadingInterval = setInterval(() => {
                loadingProgress += 10;
                document.getElementById('loadingFill').style.width = loadingProgress + '%';
                if (loadingProgress >= 100) {
                    clearInterval(loadingInterval);
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 500);
                }
            }, 200);
        }
        
        // è®¾ç½®å½©è™¹å…ƒç´ 
        function setupRainbowElement() {
            const rainbow = document.getElementById('rainbow');
            rainbow.innerHTML = generateRainbowSVG();
        }
        
        // ç”Ÿæˆå½©è™¹SVG - ä¿®æ”¹å½©è™¹ä½ç½®åˆ°å¤©ç©º
        function generateRainbowSVG() {
            const colors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
            let svg = '<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">';
            
            // ä¿®æ”¹å½©è™¹çš„ä½ç½®ï¼Œè®©å®ƒå‡ºç°åœ¨å¤©ç©ºè€Œä¸æ˜¯åœ°é¢
            for (let i = 0; i < colors.length; i++) {
                const radius = 500 + i * 20;
                // æ”¹å˜èµ·å§‹ç‚¹å’Œç»ˆç‚¹ï¼Œè®©å½©è™¹å‡ºç°åœ¨å¤©ç©º
                svg += `<path d="M-100,${gameHeight/3} a${radius},${radius} 0 0,1 ${gameWidth + 200},0" 
                       fill="none" stroke="${colors[i]}" stroke-width="10" stroke-opacity="0.8" />`;
            }
            
            svg += '</svg>';
            return svg;
        }
        
        // è®¾ç½®å·²æç¤ºå•è¯æŒ‰é’®
        function setupHintedWordsButton() {
            const hintedWordsBtn = document.getElementById('hintedWordsButton');
            hintedWordsBtn.addEventListener('click', () => {
                wordArchiveVisible = !wordArchiveVisible;
                document.getElementById('wordArchive').style.display = wordArchiveVisible ? 'block' : 'none';
                hintedWordsBtn.classList.toggle('active', wordArchiveVisible);
            });
        }
        
        // è®¾ç½®å­£èŠ‚åˆ‡æ¢
        function setupSeasonToggle() {
            const toggle = document.getElementById('seasonToggle');
            toggle.addEventListener('click', () => {
                // å¾ªç¯åˆ‡æ¢å­£èŠ‚
                switch(currentSeason) {
                    case 'spring':
                        startSeasonTransition('summer');
                        toggle.textContent = 'å››å­£ï¼šå¤å­£';
                        break;
                    case 'summer':
                        startSeasonTransition('autumn');
                        toggle.textContent = 'å››å­£ï¼šç§‹å­£';
                        break;
                    case 'autumn':
                        startSeasonTransition('winter');
                        toggle.textContent = 'å››å­£ï¼šå†¬å­£';
                        break;
                    case 'winter':
                        startSeasonTransition('spring');
                        toggle.textContent = 'å››å­£ï¼šæ˜¥å­£';
                        break;
                }
            });
        }
        
        // å¼€å§‹å­£èŠ‚è¿‡æ¸¡
        function startSeasonTransition(newSeason) {
            nextSeason = newSeason;
            seasonTransition = 0;
            seasonChangeStarted = true;
        }
        
        // è®¾ç½®èƒŒè¯µæ¨¡å¼åˆ‡æ¢
        function setupStudyModeToggle() {
            const toggle = document.getElementById('studyModeToggle');
            const hintedWordsBtn = document.getElementById('hintedWordsButton');
            
            toggle.addEventListener('click', () => {
                studyMode = !studyMode;
                toggle.textContent = studyMode ? 'èƒŒè¯µæ¨¡å¼ï¼šå¼€' : 'èƒŒè¯µæ¨¡å¼ï¼šå…³';
                toggle.classList.toggle('active', studyMode);
                
                // æ›´æ–°UIæ˜¾ç¤º
                if (studyMode) {
                    // æ˜¾ç¤ºå·²æç¤ºå•è¯æŒ‰é’®ï¼Œä½†é»˜è®¤ä¸æ˜¾ç¤ºå•è¯åˆ—è¡¨
                    hintedWordsBtn.style.display = 'flex';
                    document.getElementById('wordArchive').style.display = 'none';
                    wordArchiveVisible = false;
                } else {
                    // éèƒŒè¯µæ¨¡å¼éšè—æŒ‰é’®å’Œåˆ—è¡¨
                    hintedWordsBtn.style.display = 'none';
                    document.getElementById('wordArchive').style.display = 'none';
                    wordArchiveVisible = false;
                }
            });
        }
        
        // è®¾ç½®å•è¯æ¡£æ¡ˆåŒºåŸŸ
        function setupWordArchive() {
            const exportButton = document.getElementById('exportButton');
            exportButton.addEventListener('click', exportHintedWords);
        }
        
        // å¯¼å‡ºæç¤ºè¿‡çš„å•è¯ä¸ºExcel
        function exportHintedWords() {
            if (hintedWords.length === 0) {
                alert('æ²¡æœ‰éœ€è¦å¯¼å‡ºçš„å•è¯ï¼');
                return;
            }
            
            // å‡†å¤‡å¯¼å‡ºæ•°æ®
            const exportData = hintedWords.map(word => [
                word.english,
                word.chinese,
                word.partOfSpeech,
                word.hintCount
            ]);
            
            // æ·»åŠ è¡¨å¤´
            exportData.unshift(['è‹±æ–‡', 'ä¸­æ–‡', 'è¯æ€§', 'æç¤ºæ¬¡æ•°']);
            
            // åˆ›å»ºå·¥ä½œç°¿
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(exportData);
            
            // å°†å·¥ä½œè¡¨æ·»åŠ åˆ°å·¥ä½œç°¿
            XLSX.utils.book_append_sheet(wb, ws, 'æç¤ºå•è¯');
            
            // å¯¼å‡ºExcelæ–‡ä»¶
            XLSX.writeFile(wb, 'æç¤ºè¿‡çš„å•è¯.xlsx');
        }
        
        // æ›´æ–°å•è¯æ¡£æ¡ˆåˆ—è¡¨
        function updateWordArchive() {
            const container = document.getElementById('archivedWordsList');
            container.innerHTML = '';
            
            if (hintedWords.length === 0) {
                container.innerHTML = '<p style="text-align:center;">è¿˜æ²¡æœ‰æç¤ºè¿‡çš„å•è¯</p>';
                return;
            }
            
            // æŒ‰æç¤ºæ¬¡æ•°é™åºæ’åº
            const sortedWords = [...hintedWords].sort((a, b) => b.hintCount - a.hintCount);
            
            for (const word of sortedWords) {
                const wordElement = document.createElement('div');
                wordElement.className = 'archiveWord';
                
                const englishDiv = document.createElement('div');
                englishDiv.textContent = word.english;
                
                const chineseDiv = document.createElement('div');
                chineseDiv.textContent = word.chinese;
                
                const posDiv = document.createElement('div');
                posDiv.textContent = word.partOfSpeech || 'æ— ';
                
                const countDiv = document.createElement('div');
                countDiv.className = 'hintCount';
                countDiv.textContent = `æç¤º: ${word.hintCount}`;
                
                wordElement.appendChild(englishDiv);
                wordElement.appendChild(chineseDiv);
                wordElement.appendChild(posDiv);
                wordElement.appendChild(countDiv);
                
                container.appendChild(wordElement);
            }
            
            // æ›´æ–°å·²æç¤ºæŒ‰é’®ä¸Šçš„æ•°å­—
            document.getElementById('hintedWordsButton').textContent = 
                `å·²æç¤ºå•è¯ (${hintedWords.length})`;
        }
        
        // æ·»åŠ å•è¯åˆ°æç¤ºåˆ—è¡¨
        function addWordToHinted(word) {
            // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨åˆ—è¡¨ä¸­
            const existingIndex = hintedWords.findIndex(w => w.english === word.english);
            
            if (existingIndex >= 0) {
                // å¢åŠ æç¤ºæ¬¡æ•°
                hintedWords[existingIndex].hintCount++;
            } else {
                // æ·»åŠ æ–°å•è¯
                hintedWords.push({
                    ...word,
                    hintCount: 1
                });
            }
            
            // æ›´æ–°æ˜¾ç¤º
            updateWordArchive();
        }
        
        // è°ƒæ•´Canvaså¤§å° - ä¿®æ”¹äº†æ¨ªå±é€‚é…
        function resizeCanvas() {
            // æ£€æµ‹è®¾å¤‡æ–¹å‘
            const isLandscape = window.innerWidth > window.innerHeight;
            
            if (isLandscape) {
                // æ¨ªå± - æ›´å¥½çš„é€‚é…ç§»åŠ¨è®¾å¤‡
                gameWidth = window.innerWidth;
                gameHeight = window.innerHeight;
            } else {
                // ç«–å±
                gameWidth = window.innerWidth;
                gameHeight = window.innerHeight - 10; // å‡å°‘10pxé˜²æ­¢æº¢å‡º
            }
            
            canvas.width = gameWidth;
            canvas.height = gameHeight;
            
            // æ›´æ–°ç›¸æœºå°ºå¯¸
            camera.width = gameWidth;
            camera.height = gameHeight;
            
            // å¦‚æœå½©è™¹å·²æ¿€æ´»ï¼Œéœ€è¦é‡æ–°ç”ŸæˆSVG
            if (weatherEffects.rainbow.active) {
                document.getElementById('rainbow').innerHTML = generateRainbowSVG();
            }
            
            // é‡ç»˜æ¸¸æˆ
            if (gameStarted) {
                drawGame();
            }
        }
        
        // è®¾ç½®è§’è‰²é€‰æ‹©
        function setupCharacterSelection() {
            const characterButtons = document.querySelectorAll('.characterButton');
            characterButtons.forEach(button => {
                button.addEventListener('click', () => {
                    characterButtons.forEach(b => b.classList.remove('selected'));
                    button.classList.add('selected');
                    selectedCharacter = button.getAttribute('data-character');
                    
                    switch (selectedCharacter) {
                        case 'stickman':
                            player.color = 'white';
                            player.outlineColor = 'black';
                            break;
                        case 'ninja':
                            player.color = '#4CAF50';
                            player.outlineColor = '#194D23';
                            break;
                        case 'robot':
                            player.color = '#f472b6';
                            player.outlineColor = '#9d174d';
                            break;
                    }
                });
            });
        }
        
        // è®¾ç½®æ–‡ä»¶è¾“å…¥
        function setupFileInput() {
    const fileInput = document.getElementById('fileInput');
    // å¢åŠ .numbersæ ¼å¼
    fileInput.setAttribute('accept', '.csv,.xlsx,.xls,.numbers');
    fileInput.addEventListener('change', handleFileUpload);
}
        
        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const fileName = file.name.toLowerCase();
    
    document.getElementById('loading').style.display = 'flex';
    let loadingProgress = 0;
    const loadingInterval = setInterval(() => {
        loadingProgress += 5;
        document.getElementById('loadingFill').style.width = loadingProgress + '%';
        if (loadingProgress >= 90) {
            clearInterval(loadingInterval);
        }
    }, 100);
    
    try {
        if (fileName.endsWith('.csv')) {
            // å¤„ç†CSVæ–‡ä»¶
            Papa.parse(file, {
                complete: function(results) {
                    processWordData(results.data);
                    finishLoading();
                },
                header: false,
                error: function(error) {
                    alert('CSVè§£æé”™è¯¯ï¼Œè¯·å°è¯•Excelæˆ–CSVæ ¼å¼æ–‡æ¡£');
                    document.getElementById('loading').style.display = 'none';
                }
            });
        } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls') || fileName.endsWith('.numbers')) {
            // å¤„ç†Excelæ–‡ä»¶æˆ–Numbersæ–‡ä»¶
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    processWordData(jsonData);
                    finishLoading();
                } catch (error) {
                    alert('æ–‡ä»¶è§£æé”™è¯¯ï¼Œè¯·å°è¯•Excelæˆ–CSVæ ¼å¼æ–‡æ¡£');
                    document.getElementById('loading').style.display = 'none';
                }
            };
            reader.onerror = function() {
                alert('æ–‡ä»¶è¯»å–é”™è¯¯ï¼Œè¯·å°è¯•Excelæˆ–CSVæ ¼å¼æ–‡æ¡£');
                document.getElementById('loading').style.display = 'none';
            };
            reader.readAsArrayBuffer(file);
        } else {
            alert('è¯·ä¸Šä¼ CSVã€Excelæˆ–Numbersæ–‡ä»¶');
            document.getElementById('loading').style.display = 'none';
        }
    } catch (error) {
        alert('æ–‡ä»¶å¤„ç†é”™è¯¯ï¼Œè¯·å°è¯•Excelæˆ–CSVæ ¼å¼æ–‡æ¡£');
        document.getElementById('loading').style.display = 'none';
    }
}
        // å®ŒæˆåŠ è½½
        function finishLoading() {
            document.getElementById('loadingFill').style.width = '100%';
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('startButton').disabled = false;
                if (wordList.length > 0) {
                    document.getElementById('startButton').textContent = `å¼€å§‹æ¸¸æˆ (${wordList.length}ä¸ªå•è¯)`;
                }
            }, 500);
        }
        
        // å¤„ç†å•è¯æ•°æ®
        function processWordData(data) {
            wordList = [];
            
            // è·³è¿‡å¯èƒ½çš„æ ‡é¢˜è¡Œ
            let startIndex = 0;
            if (data.length > 0 && 
                (typeof data[0][0] === 'string' && (
                    data[0][0].toLowerCase().includes('english') || 
                    data[0][0].toLowerCase().includes('word') || 
                    data[0][0].toLowerCase().includes('å•è¯')))) {
                startIndex = 1;
            }
            
            for (let i = startIndex; i < data.length; i++) {
                const row = data[i];
                if (row && row.length >= 2) {
                    const english = row[0] ? String(row[0]).trim() : '';
                    const chinese = row[1] ? String(row[1]).trim() : '';
                    const partOfSpeech = row.length >= 3 ? String(row[2]).trim() : '';
                    
                    if (english && chinese) {
                        wordList.push({
                            english: english,
                            chinese: chinese,
                            partOfSpeech: partOfSpeech,
                            visited: false,
                            index: wordList.length
                        });
                    }
                }
            }
            
            // æ‰“ä¹±å•è¯é¡ºåº
            wordList = shuffleArray(wordList);
            
            // æ·»åŠ ç´¢å¼•å€¼ï¼Œç”¨äºè·Ÿè¸ªè¿›åº¦
            for (let i = 0; i < wordList.length; i++) {
                wordList[i].index = i;
            }
            
            console.log(`æˆåŠŸåŠ è½½ ${wordList.length} ä¸ªå•è¯`);
        }
        
        // æ´—ç‰Œæ•°ç»„
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }
        
        // è®¾ç½®å¼€å§‹æŒ‰é’®
        function setupStartButton() {
            const startButton = document.getElementById('startButton');
            startButton.addEventListener('click', () => {
                if (wordList.length === 0) {
                    alert('è¯·å…ˆå¯¼å…¥å•è¯è¡¨ï¼');
                    return;
                }
                
                document.getElementById('startScreen').style.display = 'none';
                startGame();
            });
        }
        // è®¾ç½®æ–°æ‰‹æŒ‡å—æŒ‰é’®
function setupTutorialButton() {
    const tutorialButton = document.getElementById('tutorialButton');
    const tutorialScreen = document.getElementById('tutorialScreen');
    const closeTutorial = document.getElementById('closeTutorial');
    
    tutorialButton.addEventListener('click', () => {
        tutorialScreen.style.display = 'flex';
    });
    
    closeTutorial.addEventListener('click', () => {
        tutorialScreen.style.display = 'none';
    });
}
        
        // è®¾ç½®æš‚åœæŒ‰é’®
        function setupPauseButton() {
            const pauseButton = document.getElementById('pauseButton');
            pauseButton.addEventListener('click', () => {
                gamePaused = true;
                document.getElementById('pauseMenu').style.display = 'flex';
                cancelAnimationFrame(animationId);
            });
            
            const resumeButton = document.getElementById('resumeButton');
            resumeButton.addEventListener('click', () => {
                document.getElementById('pauseMenu').style.display = 'none';
                gamePaused = false;
                lastTime = performance.now();
                animationId = requestAnimationFrame(gameLoop);
            });
            
            const restartButton = document.getElementById('restartButton');
            restartButton.addEventListener('click', () => {
                // ä¿®å¤é‡æ–°å¼€å§‹å¡é¡¿é—®é¢˜
                document.getElementById('pauseMenu').style.display = 'none';
                gamePaused = false;
                
                // æ¸…ç©ºæç¤ºè¿‡çš„å•è¯
                hintedWords = [];
                updateWordArchive();
                
                // å»¶è¿Ÿä¸€å¸§å¯åŠ¨é‡æ–°å¼€å§‹ï¼Œé¿å…å¡é¡¿
                setTimeout(() => {
                    restartGame();
                }, 0);
            });
            
            const returnButton = document.getElementById('returnButton');
            returnButton.addEventListener('click', () => {
                // ä¿®å¤è¿”å›ä¸»ç•Œé¢å¡é¡¿é—®é¢˜ - åˆ†æ­¥å¤„ç†
                document.getElementById('pauseMenu').style.display = 'none';
                gamePaused = false;
                
                // ç¬¬ä¸€æ­¥ï¼šåœæ­¢æ¸¸æˆå¾ªç¯
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                
                // ç¬¬äºŒæ­¥ï¼šæ·¡å‡ºæ¸¸æˆç”»é¢ã€å›åˆ°åŠ è½½ä¸­çŠ¶æ€
                document.getElementById('loading').style.display = 'flex';
                document.getElementById('loadingFill').style.width = '0%';
                
                let progress = 0;
                const interval = setInterval(() => {
                    progress += 5;
                    document.getElementById('loadingFill').style.width = `${progress}%`;
                    
                    if (progress >= 100) {
                        clearInterval(interval);
                        
                        // ç¬¬ä¸‰æ­¥ï¼šé‡ç½®æ¸¸æˆçŠ¶æ€
                        setTimeout(() => {
                            resetGame();
                            
                            // ç¬¬å››æ­¥ï¼šéšè—åŠ è½½ï¼Œæ˜¾ç¤ºä¸»ç•Œé¢
                            document.getElementById('loading').style.display = 'none';
                            document.getElementById('startScreen').style.display = 'flex';
                            
                            // é‡æ–°è®¾ç½®æ–‡ä»¶ä¸Šä¼ æŒ‰é’®
                            document.getElementById('fileInput').value = '';
                            document.getElementById('startButton').textContent = 'å¼€å§‹æ¸¸æˆ';
                        }, 100);
                    }
                }, 20);
            });
        }
        
        // é‡ç½®æ¸¸æˆ
        function resetGame() {
            // æ¸…ç©ºå•è¯åˆ—è¡¨ï¼Œè¿™æ ·ç”¨æˆ·éœ€è¦é‡æ–°ä¸Šä¼ æ–‡ä»¶
            wordList = [];
            currentWordIndex = 0;
            visibleWordIndex = 0;
            score = 0;
            hintedWords = [];
            
            // é‡ç½®å¤©æ°”æ•ˆæœ
            resetWeatherEffects();
            
            // é‡ç½®å­£èŠ‚
            currentSeason = 'spring';
            seasonTransition = 0;
            seasonChangeStarted = false;
            document.getElementById('seasonToggle').textContent = 'å››å­£ï¼šæ˜¥å­£';
            
            // é‡ç½®èƒŒè¯µæ¨¡å¼
            studyMode = false;
            wordArchiveVisible = false;
            document.getElementById('studyModeToggle').textContent = 'èƒŒè¯µæ¨¡å¼ï¼šå…³';
            document.getElementById('studyModeToggle').classList.remove('active');
            document.getElementById('wordArchive').style.display = 'none';
            document.getElementById('hintedWordsButton').style.display = 'none';
            
            // é‡ç½®UI
            document.getElementById('score').textContent = 'å•è¯: 0 / 0';
            document.getElementById('progressFill').style.width = '0%';
            
            // æ¸…ç©ºæ¸¸æˆå¯¹è±¡
            gameObjects.length = 0;
            platforms.length = 0;
            jumpboards.length = 0;
            birds.length = 0; // æ¸…ç©ºé¸Ÿç±»
            ducks.length = 0; // æ¸…ç©ºé¸­å­
            fishes.length = 0; // æ›¿ä»£ducks
            ponds.length = 0; // æ¸…ç©ºæ± å¡˜
            if (window.specialPlatforms) window.specialPlatforms.length = 0;
            if (window.hazards) window.hazards.length = 0;
            
            // é‡ç½®ç©å®¶ä½ç½®
            player.x = 100;
            player.y = gameHeight / 2;
            player.velY = 0;
            player.isJumping = false;
            
            // æ¸…é™¤å¯èƒ½çš„æ´»åŠ¨å›¾æ ‡
            activeVolumeIcon = null;
            activeHintButton = null;
            document.getElementById('volumeIcon').style.display = 'none';
            document.getElementById('hintButton').style.display = 'none';
            
            gameRunning = false;
            gameStarted = false;
        }
        
        // é‡ç½®å¤©æ°”æ•ˆæœ
        function resetWeatherEffects() {
            // é‡ç½®é—ªç”µ
            weatherEffects.lightning.active = false;
            weatherEffects.lightning.opacity = 0;
            
            // é‡ç½®æ²™å°˜æš´
            weatherEffects.sandstorm.active = false;
            weatherEffects.sandstorm.particles = [];
            weatherEffects.sandstorm.intensity = 0;
            
            // é‡ç½®å½©è™¹
            weatherEffects.rainbow.active = false;
            weatherEffects.rainbow.opacity = 0;
            document.getElementById('rainbow').style.opacity = '0';
        }
        
        // è®¾ç½®é”®ç›˜æ§åˆ¶
        function setupKeyboardControls() {
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                
                if (e.key === 'ArrowUp' || e.key === ' ' || e.key === 'w') {
                    if (!player.isJumping && gameRunning) {
                        player.velY = -player.jumpForce;
                        player.isJumping = true;
                    }
                }
                
                // é˜²æ­¢æ–¹å‘é”®æ»šåŠ¨é¡µé¢
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                    e.preventDefault();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
        }
        
        // è®¾ç½®æ‘‡æ†æ§åˆ¶
        function setupJoystick() {
            const joystick = document.getElementById('joystick');
            const knob = document.getElementById('joystickKnob');
            const joystickRect = joystick.getBoundingClientRect();
            const joystickRadius = joystickRect.width / 2;
            const knobRadius = knob.offsetWidth / 2;
            
            let touchId = null;
            
            const getJoystickPosition = (x, y) => {
                const centerX = joystickRect.left + joystickRadius;
                const centerY = joystickRect.top + joystickRadius;
                
                let deltaX = x - centerX;
                let deltaY = y - centerY;
                
                // è®¡ç®—è·ç¦»å’Œè§’åº¦
                const distance = Math.min(joystickRadius - knobRadius, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const angle = Math.atan2(deltaY, deltaX);
                
                // è®¡ç®—æ–°ä½ç½®
                const knobX = distance * Math.cos(angle);
                const knobY = distance * Math.sin(angle);
                
                return { knobX, knobY, distance, angle };
            };
            
            // æ›´æ–°æ‘‡æ†ä½ç½®
            const updateJoystick = (x, y) => {
                const { knobX, knobY, distance, angle } = getJoystickPosition(x, y);
                
                knob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
                
                joystickActive = distance > 10;
                joystickAngle = angle;
                joystickDistance = distance / (joystickRadius - knobRadius);
            };
            
            // é‡ç½®æ‘‡æ†
            const resetJoystick = () => {
                knob.style.transform = 'translate(-50%, -50%)';
                joystickActive = false;
                touchId = null;
            };
            
            // è§¦æ‘¸äº‹ä»¶
            joystick.addEventListener('touchstart', (e) => {
                if (touchId === null) {
                    touchId = e.changedTouches[0].identifier;
                    updateJoystick(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
                }
            });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchId) {
                        updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                        break;
                    }
                }
            });
            
            const handleTouchEnd = (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === touchId) {
                        resetJoystick();
                        break;
                    }
                }
            };
            
            joystick.addEventListener('touchend', handleTouchEnd);
            joystick.addEventListener('touchcancel', handleTouchEnd);
        }
        
        // è®¾ç½®è·³è·ƒæŒ‰é’®
        function setupJumpButton() {
            const jumpButton = document.getElementById('jumpButton');
            
            jumpButton.addEventListener('touchstart', () => {
                if (!player.isJumping && gameRunning) {
                    player.velY = -player.jumpForce;
                    player.isJumping = true;
                }
            });
        }
        
        // æ£€æŸ¥ç¢°æ’
        function checkCollision(obj1, obj2) {
            return (
                obj1.x < obj2.x + obj2.width &&
                obj1.x + obj1.width > obj2.x &&
                obj1.y < obj2.y + obj2.height &&
                obj1.y + obj1.height > obj2.y
            );
        }
        
        // æ·»åŠ è£…é¥°ç‰©
        function addDecorations(x, groundY) {
            // æ·»åŠ çŒæœ¨ä¸›
            for (let i = 0; i < 3; i++) {
                const bushX = x + Math.random() * 400 - 200;
                createBush(bushX, groundY);
            }
            
            // æ·»åŠ èŠ±æœµ
            for (let i = 0; i < 5; i++) {
                const flowerX = x + Math.random() * 500 - 250;
                createFlower(flowerX, groundY);
            }
            
            // éšæœºæ·»åŠ æ‚¬å´–æˆ–è—¤è”“
            if (Math.random() > 0.7) {
                if (Math.random() > 0.5) {
                    createCliff(x + 200, groundY);
                } else {
                    createVine(x + 200, groundY - 300); // è—¤è”“ä»ä¸Šæ–¹å‚ä¸‹
                }
            }
            
            // éšæœºæ·»åŠ å¤©ç©ºä¸­çš„é¸Ÿ
            if (Math.random() > 0.8) {
                createBird(x + Math.random() * 400, groundY - 300 - Math.random() * 200);
            }
            
            // éšæœºæ·»åŠ æ¢¯å­
            if (Math.random() > 0.85) {
                createLadder(x + 150, groundY - 300);
            }
            
            // éšæœºæ·»åŠ æ± å¡˜
            if (Math.random() > 0.9) {
                createPond(x + 300, groundY - 20);
            }
        }
        
       // åˆ›å»ºæ± å¡˜ - ä¿®æ­£é¸­å­çš„æ˜¾ç¤ºé—®é¢˜
// ä¿®æ”¹createPondå‡½æ•°ï¼Œçº¦åœ¨1950è¡Œå·¦å³
function createPond(x, groundY) {
    const pondWidth = 350 + Math.random() * 150;
    const pondHeight = 30 + Math.random() * 20;
    
    const pond = {
        x: x,
        y: groundY,
        width: pondWidth,
        height: pondHeight,
        ducks: [],
        type: 'decoration',
        fishes: [], // è¿™ä¸ªæ± å¡˜ä¸­çš„é±¼
        maxDucks: 2, // è®¾ç½®æœ€å¤§é¸­å­æ•°é‡
        maxFishes: 2, // è®¾ç½®æœ€å¤§é±¼æ•°é‡
        draw: function(ctx) {
            // ç»˜åˆ¶æ°´é¢
            const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
            gradient.addColorStop(0, '#4FC3F7');
            gradient.addColorStop(1, '#0288D1');
            
            ctx.fillStyle = gradient;
            
            // ç»˜åˆ¶ä¸€ä¸ªæ¤­åœ†å½¢çš„æ± å¡˜
            ctx.beginPath();
            ctx.ellipse(
                this.x + this.width/2, 
                this.y + this.height/2, 
                this.width/2, 
                this.height, 
                0, 0, Math.PI * 2
            );
            ctx.fill();
            
            // ç»˜åˆ¶æ°´æ³¢çº¹
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < 3; i++) {
                const waveRadius = (this.width/2) * (0.6 + i * 0.15);
                const waveHeight = this.height * (0.6 + i * 0.12);
                const waveOffset = Math.sin(gameTime * 0.001 + i) * 5;
                
                ctx.beginPath();
                ctx.ellipse(
                    this.x + this.width/2 + waveOffset, 
                    this.y + this.height/2, 
                    waveRadius, 
                    waveHeight, 
                    0, 0, Math.PI * 2
                );
                ctx.stroke();
            }
            
           // ç¡®ä¿æ± å¡˜åˆ›å»ºåç«‹å³åˆ›å»ºé¸­å­ï¼Œä½†ä¸è¶…è¿‡æœ€å¤§é™åˆ¶
           if (this.ducks.length < this.maxDucks) {
                // è®¡ç®—éœ€è¦æ·»åŠ çš„é¸­å­æ•°é‡ï¼Œæœ€å¤šæ·»åŠ åˆ°æœ€å¤§é™åˆ¶
                const duckCount = Math.min(this.maxDucks - this.ducks.length, 
                                          1 + Math.floor(Math.random()));
                
                // è®¡ç®—å®‰å…¨åŒºåŸŸï¼Œé¿å…é¸­å­é è¿‘è¾¹ç¼˜
                const safeMargin = 60; // å¢åŠ è¾¹ç¼˜å®‰å…¨è·ç¦»
                const safeLeft = this.x + safeMargin;
                const safeRight = this.x + this.width - safeMargin;
                
                for (let i = 0; i < duckCount; i++) {
                    // ç¡®ä¿é¸­å­åœ¨å®‰å…¨åŒºåŸŸå†…
                    const duckX = safeLeft + Math.random() * (safeRight - safeLeft);
                    const duck = createDuck(duckX, this.y - 10);
                    this.ducks.push(duck);
                }
            }
            
            // å¦‚æœé¸­å­ç¦»å¼€äº†æ± å¡˜å®‰å…¨åŒºåŸŸï¼Œè®©å®ƒä»¬è½¬å‘
            const safeMargin = 40; // é¸­å­è½¬å‘çš„è¾¹ç¼˜è·ç¦»
            for (let i = 0; i < this.ducks.length; i++) {
                const duck = this.ducks[i];
                if (duck.x < this.x + safeMargin) {
                    duck.direction = 1; // å‘å³ç§»åŠ¨
                    duck.x = this.x + safeMargin; // é˜²æ­¢å¡åœ¨è¾¹ç¼˜
                } else if (duck.x > this.x + this.width - safeMargin) {
                    duck.direction = -1; // å‘å·¦ç§»åŠ¨
                    duck.x = this.x + this.width - safeMargin; // é˜²æ­¢å¡åœ¨è¾¹ç¼˜
                }
            }
        }
    };
    
    ponds.push(pond);
    




    gameObjects.push(pond);
    
    // æ·»åŠ æ± å¡˜è¾¹ç¼˜æ¤ç‰©è£…é¥° - ç¡®ä¿æ°´è‰ä¸ä¼šå¤ªé è¿‘è¾¹ç¼˜
    const safeMargin = 30; // æ°´è‰è¾¹ç¼˜å®‰å…¨è·ç¦»
    const plantableLeft = x + safeMargin;
    const plantableRight = x + pondWidth - safeMargin;
    
    for (let i = 0; i < 3; i++) {
        // ç¡®ä¿æ¤ç‰©åœ¨æ± å¡˜çš„å®‰å…¨åŒºåŸŸå†…
        const plantX = plantableLeft + Math.random() * (plantableRight - plantableLeft);
        const plantY = groundY - 10;
        
        const plant = {
            x: plantX,
            y: plantY,
            width: 20,
            height: 30,
            type: 'decoration',
            draw: function(ctx) {
                // ç»˜åˆ¶æ°´è‰æˆ–èŠ¦è‹‡
                ctx.fillStyle = '#4CAF50';
                
                for (let j = 0; j < 3; j++) {
                    const stemHeight = 20 + Math.random() * 15;
                    const stemWidth = 2;
                    const stemX = this.x + j * 7 - 7;
                    const swayAmount = Math.sin(gameTime * 0.002 + j) * 3;
                    
                    // ç»˜åˆ¶èŒ
                    ctx.beginPath();
                    ctx.moveTo(stemX, this.y);
                    ctx.quadraticCurveTo(
                        stemX + swayAmount, 
                        this.y - stemHeight/2,
                        stemX + swayAmount * 2, 
                        this.y - stemHeight
                    );
                    ctx.lineWidth = stemWidth;
                    ctx.strokeStyle = '#388E3C';
                    ctx.stroke();
                    
                    // ç»˜åˆ¶å¶ç‰‡
                    if (Math.random() > 0.5) {
                        ctx.beginPath();
                        ctx.ellipse(
                            stemX + swayAmount * 1.5, 
                            this.y - stemHeight * 0.7,
                            1,
                            6,
                            Math.PI/4 + Math.sin(gameTime * 0.001) * 0.2,
                            0, Math.PI * 2
                        );
                        ctx.fillStyle = '#4CAF50';
                        ctx.fill();
                    }
                }
            }
        };
        
        gameObjects.push(plant);
    }
     // éšæœºæ·»åŠ 1-3æ¡é±¼åˆ°æ± å¡˜ä¸­
     const fishCount = Math.min(pond.maxFishes, 1 + Math.floor(Math.random()));
    for (let i = 0; i < fishCount; i++) {
        // è®¡ç®—å®‰å…¨åŒºåŸŸï¼Œé¿å…é±¼é è¿‘è¾¹ç¼˜
        const safeMargin = 40;
        const safeLeft = pond.x + safeMargin;
        const safeRight = pond.x + pond.width - safeMargin;
        
        // ç¡®ä¿é±¼åœ¨å®‰å…¨åŒºåŸŸå†…
        const fishX = safeLeft + Math.random() * (safeRight - safeLeft);
        // è®©é±¼åœ¨æ°´ä¸­éšæœºæ·±åº¦
        const fishY = pond.y + 5 + Math.random() * pond.height * 0.7;
        
        const newFish = createFish(fishX, fishY);
        pond.fishes.push(newFish);
    }
    
    return pond;
}

        // åˆ›å»ºé±¼
function createFish(x, y) {
    // éšæœºå¤§å°å’Œé¢œè‰²
    const fishSize = 10 + Math.random() * 15;
    
    // éšæœºæ–¹å‘
    const direction = Math.random() > 0.5 ? 1 : -1;
    
    // å­£èŠ‚ç›¸å…³çš„é±¼é¢œè‰²
    const fishColors = {
        spring: ['#ff9e64', '#ffcf56', '#55c6ff'],
        summer: ['#ff7b54', '#ffb26b', '#4d96ff'],
        autumn: ['#bc6c25', '#dda15e', '#606c38'],
        winter: ['#48cae4', '#90e0ef', '#ade8f4']
    };
    
    const color = fishColors[currentSeason][Math.floor(Math.random() * fishColors[currentSeason].length)];
    
    const fish = {
        x: x,
        y: y,
        width: fishSize * 2,
        height: fishSize,
        direction: direction, // 1ä»£è¡¨å‘å³ï¼Œ-1ä»£è¡¨å‘å·¦
        speed: 0.5 + Math.random() * 0.5,
        tailPhase: Math.random() * Math.PI * 2, // å°¾å·´æ‘†åŠ¨çš„åˆå§‹ç›¸ä½
        tailFrequency: 0.1 + Math.random() * 0.05, // å°¾å·´æ‘†åŠ¨çš„é¢‘ç‡
        color: color,
        type: 'decoration',
        originalY: y, // ä¿å­˜åŸå§‹Yåæ ‡ï¼Œç”¨äºä¸Šä¸‹æµ®åŠ¨
        update: function(deltaTime) {
            // ç§»åŠ¨é±¼
            this.x += this.direction * this.speed;
            
            // ä¸Šä¸‹æµ®åŠ¨
            this.y = this.originalY + Math.sin(gameTime * 0.001) * 5;
            
            // æ›´æ–°å°¾å·´æ‘†åŠ¨
            this.tailPhase += this.tailFrequency;
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦è½¬å‘ - ä¸ºäº†ç®€å•èµ·è§ï¼Œåªåœ¨æ± å¡˜è¾¹ç¼˜è½¬å‘
            // æ‰¾åˆ°è¿™æ¡é±¼æ‰€åœ¨çš„æ± å¡˜
            for (let i = 0; i < ponds.length; i++) {
                const pond = ponds[i];
                
                // æ£€æŸ¥é±¼æ˜¯å¦åœ¨è¿™ä¸ªæ± å¡˜ä¸­
                if (pond.fishes.includes(this)) {
                    // è®¾ç½®å®‰å…¨è¾¹ç•Œ
                    const safeLeft = pond.x + 40;
                    const safeRight = pond.x + pond.width - 40;
                    
                    // å¦‚æœé±¼æ¥è¿‘è¾¹ç¼˜ï¼Œåˆ™è½¬å‘
                    if ((this.x < safeLeft && this.direction < 0) || 
                        (this.x > safeRight && this.direction > 0)) {
                        this.direction *= -1;
                    }
                    
                    break;
                }
            }
        },
        draw: function(ctx) {
            ctx.save();
            
            // æ ¹æ®é±¼çš„æ–¹å‘ç¿»è½¬
            if (this.direction < 0) {
                ctx.translate(this.x + this.width, this.y);
                ctx.scale(-1, 1);
                ctx.translate(-this.width, 0);
            } else {
                ctx.translate(this.x, this.y);
            }
            
            // é±¼èº«ä½“
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.ellipse(this.width / 2, this.height / 2, this.width / 2 - 5, this.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // é±¼å°¾
            const tailWidth = this.width * 0.3;
            const tailHeight = this.height * 0.8;
            const tailX = 0;
            const tailY = this.height / 2;
            
            // å°¾å·´æ‘†åŠ¨è§’åº¦
            const tailAngle = Math.sin(this.tailPhase) * 0.3;
            
            ctx.save();
            ctx.translate(tailX, tailY);
            ctx.rotate(tailAngle);
            
            // ç»˜åˆ¶å°¾å·´
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-tailWidth / 2, -tailHeight / 2);
            ctx.lineTo(-tailWidth, 0);
            ctx.lineTo(-tailWidth / 2, tailHeight / 2);
            ctx.closePath();
            
            ctx.fillStyle = adjustBrightness(this.color, 0.8);
            ctx.fill();
            
            ctx.restore();
            
            // é±¼é³
            const finX = this.width / 2;
            const finY = this.height / 2;
            const finWidth = this.width * 0.2;
            const finHeight = this.height * 0.4;
            
            // ä¸Šé³
            ctx.beginPath();
            ctx.ellipse(finX, finY - finHeight / 2, finWidth / 2, finHeight / 2, Math.PI / 4, 0, Math.PI * 2);
            ctx.fillStyle = adjustBrightness(this.color, 0.9);
            ctx.fill();
            
            // ä¸‹é³
            ctx.beginPath();
            ctx.ellipse(finX, finY + finHeight / 2, finWidth / 2, finHeight / 2, -Math.PI / 4, 0, Math.PI * 2);
            ctx.fillStyle = adjustBrightness(this.color, 0.9);
            ctx.fill();
            
            // é±¼çœ¼
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(this.width * 0.7, this.height * 0.4, this.width * 0.08, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(this.width * 0.7, this.height * 0.4, this.width * 0.04, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
    };
    
    gameObjects.push(fish);
    fishes.push(fish);
    
    return fish;
}
        // åˆ›å»ºé¸­å­ - ä¿®æ­£é¸­å­çš„ç§»åŠ¨å’Œç»˜åˆ¶
// ä¿®æ”¹createDuckå‡½æ•°ï¼Œçº¦åœ¨2013è¡Œå·¦å³
function createDuck(x, y) {
    const duck = {
        x: x,
        y: y,
        width: 25,
        height: 20,
        type: 'decoration',
        direction: Math.random() > 0.5 ? 1 : -1,
        speed: 0.3 + Math.random() * 0.4,
        swimOffset: Math.random() * Math.PI * 2,
        color: Math.random() > 0.8 ? '#795548' : '#FFEB3B', // éšæœºæ£•è‰²æˆ–é»„è‰²é¸­å­
        update: function(deltaTime) {
            // ç§»åŠ¨é¸­å­
            this.x += this.direction * this.speed;
            
            // è½»å¾®ä¸Šä¸‹æ‘†åŠ¨æ¨¡æ‹Ÿæ¸¸æ³³
            this.swimOffset += deltaTime * 0.003;
            
            // éšæœºæ”¹å˜æ–¹å‘ï¼ˆé™ä½æ¦‚ç‡ï¼Œè®©é¸­å­ç§»åŠ¨æ›´æœ‰è¿è´¯æ€§ï¼‰
            if (Math.random() < 0.002) {
                this.direction *= -1;
            }
            
            return true; // ç¡®ä¿é¸­å­ä¸ä¼šè‡ªåŠ¨ä»æ¸¸æˆä¸­ç§»é™¤
        },
        draw: function(ctx) {
            // ä¿å­˜å½“å‰çŠ¶æ€
            ctx.save();
            
            // è®¡ç®—æ¸¸æ³³æ•ˆæœçš„å‚ç›´åç§»
            const swimY = Math.sin(this.swimOffset) * 2;
            
            // å¦‚æœå‘å·¦ç§»åŠ¨ï¼Œæ°´å¹³ç¿»è½¬
            if (this.direction < 0) {
                ctx.translate(this.x + this.width, this.y);
                ctx.scale(-1, 1);
                ctx.translate(-this.width, 0);
            } else {
                ctx.translate(this.x, this.y);
            }
            
            // ç»˜åˆ¶é¸­å­èº«ä½“
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.ellipse(this.width/2, this.height/2 + swimY, this.width/2, this.height/2 - 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶é¸­å­å¤´éƒ¨ - ç¡®ä¿å¤´åœ¨å‰æ–¹
            ctx.beginPath();
            ctx.arc(this.width - 5, this.height/2 - 2 + swimY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶é¸­å­å˜´
            ctx.fillStyle = '#FF9800';
            ctx.beginPath();
            ctx.moveTo(this.width + 3, this.height/2 - 2 + swimY);
            ctx.lineTo(this.width + 10, this.height/2 + swimY);
            ctx.lineTo(this.width + 3, this.height/2 + 2 + swimY);
            ctx.closePath();
            ctx.fill();
            
            // ç»˜åˆ¶çœ¼ç›
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(this.width, this.height/2 - 4 + swimY, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶æ°´æ³¢çº¹
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(this.width/2, this.height/2 + 5 + swimY, 15, 0, Math.PI, true);
            ctx.stroke();
            
            // æ¢å¤çŠ¶æ€
            ctx.restore();
        }
    };
    
    ducks.push(duck);
    gameObjects.push(duck);
    
    return duck;
}
        
        // åˆ›å»ºæ¢¯å­
        function createLadder(x, y) {
            const ladderHeight = 150 + Math.random() * 100;
            
            const ladder = {
                x: x,
                y: y,
                width: 40,
                height: ladderHeight,
                type: 'decoration',
                draw: function(ctx) {
                    // æ¢¯å­çš„ä¸¤æ ¹ç«–æ†
                    ctx.strokeStyle = '#8D6E63';
                    ctx.lineWidth = 4;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x, this.y + this.height);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.width, this.y);
                    ctx.lineTo(this.x + this.width, this.y + this.height);
                    ctx.stroke();
                    
                    // æ¢¯å­çš„æ¨ªæ†
                    const rungCount = Math.floor(this.height / 20);
                    for (let i = 0; i < rungCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + i * 20);
                        ctx.lineTo(this.x + this.width, this.y + i * 20);
                        ctx.stroke();
                    }
                },
                // æ¢¯å­å¯ä»¥æ”€çˆ¬
                platformCheck: function(playerObj) {
                    if (playerObj.x + playerObj.width > this.x && 
                        playerObj.x < this.x + this.width &&
                        playerObj.y + playerObj.height >= this.y &&
                        playerObj.y <= this.y + this.height) {
                        
                        // å½“ç©å®¶åœ¨æ¢¯å­ä¸Šæ—¶æœ‰ä¸Šä¸‹ç§»åŠ¨çš„è‡ªç”±
                        playerObj.isJumping = false;
                        
                        // å¯ä»¥åœ¨æ¢¯å­ä¸Šè·³è·ƒ
                        if (keys['ArrowUp'] || keys[' '] || keys['w']) {
                            playerObj.velY = -playerObj.jumpForce;
                            playerObj.isJumping = true;
                        }
                        
                        // å¯ä»¥å‘ä¸‹æ»‘åŠ¨
                        if (keys['ArrowDown'] || keys['s']) {
                            playerObj.velY = 3;
                        }
                        
                        return true;
                    }
                    return false;
                }
            };
            
            gameObjects.push(ladder);
            
            // å°†æ¢¯å­æ·»åŠ åˆ°ç‰¹æ®Šå¹³å°æ£€æŸ¥æ•°ç»„
            if (!window.specialPlatforms) window.specialPlatforms = [];
            window.specialPlatforms.push(ladder);
        }
        
  
// åˆ›å»ºé¸Ÿ
function createBird(x, y) {
    // éšæœºå¤§å°å’Œé¢œè‰²
    const birdSize = 12 + Math.random() * 8;
    
    // å­£èŠ‚ç›¸å…³çš„é¸Ÿé¢œè‰²
    const birdColors = {
        spring: ['#ff5e5b', '#d65dc0', '#8a79fc'],
        summer: ['#ff7700', '#ffaa00', '#43aa8b'],
        autumn: ['#7f5539', '#9c6644', '#594a3c'],
        winter: ['#48cae4', '#90e0ef', '#e0fbfc']
    };
    
    const color = birdColors[currentSeason][Math.floor(Math.random() * birdColors[currentSeason].length)];
    
    const bird = {
        x: x,
        y: y,
        width: birdSize * 2,
        height: birdSize,
        speedX: 1 + Math.random() * 2,
        speedY: 0,
        wingPhase: Math.random() * Math.PI * 2, // ç¿…è†€æ‹æ‰“çš„åˆå§‹ç›¸ä½
        wingFrequency: 0.2 + Math.random() * 0.1, // ç¿…è†€æ‹æ‰“çš„é¢‘ç‡
        color: color,
        lifetime: 0,
        changeDirectionTimer: 0,
        update: function(deltaTime) {
            // å¢åŠ ç”Ÿå‘½æ—¶é—´
            this.lifetime += deltaTime;
            
            // å¦‚æœé£å‡ºå¾ˆè¿œï¼Œè¿”å›falseè¡¨ç¤ºç§»é™¤
            if (this.x > camera.x + gameWidth * 3 || this.x < camera.x - gameWidth * 2) {
                return false;
            }
            
            // ç§»åŠ¨é¸Ÿ
            this.x += this.speedX;
            this.y += this.speedY;
            
            // æ›´æ–°ç¿…è†€æ‹æ‰“
            this.wingPhase += this.wingFrequency;
            
            // éšæœºæ”¹å˜æ–¹å‘
            this.changeDirectionTimer -= deltaTime;
            if (this.changeDirectionTimer <= 0) {
                // éšæœºè®¾ç½®æ–°çš„Yæ–¹å‘é€Ÿåº¦
                this.speedY = Math.random() * 2 - 1;
                
                // é‡ç½®è®¡æ—¶å™¨ï¼Œ1-3ç§’åå†æ¬¡æ”¹å˜
                this.changeDirectionTimer = 1000 + Math.random() * 2000;
            }
            
            // é˜²æ­¢é£å¾—å¤ªé«˜æˆ–å¤ªä½
            if (this.y < 50) {
                this.speedY = Math.abs(this.speedY);
            } else if (this.y > gameHeight - 100) {
                this.speedY = -Math.abs(this.speedY);
            }
            
            return true;
        },
        draw: function(ctx) {
            ctx.save();
            
            ctx.translate(this.x, this.y);
            
            // æ ¹æ®é£è¡Œæ–¹å‘è½»å¾®æ—‹è½¬
            const angle = Math.atan2(this.speedY, this.speedX);
            ctx.rotate(angle * 0.5);
            
            // é¸Ÿèº«ä½“
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.ellipse(0, 0, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // é¸Ÿå¤´
            ctx.fillStyle = adjustBrightness(this.color, 1.1);
            ctx.beginPath();
            ctx.arc(this.width / 3, -this.height / 4, this.width / 4, 0, Math.PI * 2);
            ctx.fill();
            
            // é¸Ÿå–™
            ctx.fillStyle = '#ff9a00';
            ctx.beginPath();
            ctx.moveTo(this.width / 2, -this.height / 4);
            ctx.lineTo(this.width / 2 + this.width / 5, -this.height / 8);
            ctx.lineTo(this.width / 2, 0);
            ctx.closePath();
            ctx.fill();
            
            // é¸Ÿçœ¼
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(this.width / 3 + this.width / 10, -this.height / 4 - this.height / 10, this.width / 15, 0, Math.PI * 2);
            ctx.fill();
            
            // ç¿…è†€ - ä½¿ç”¨æ­£å¼¦å‡½æ•°ä½¿ç¿…è†€ä¸Šä¸‹æ‹æ‰“
            const wingY = Math.sin(this.wingPhase) * this.height / 2;
            
            // ç¿…è†€æ”¶ç¼©æ•ˆæœ - å½“ç¿…è†€å‘ä¸Šæ—¶æ”¶ç¼©ï¼Œå‘ä¸‹æ—¶å±•å¼€
            const wingScale = 0.7 + Math.sin(this.wingPhase) * 0.3;
            
            // ä¸Šç¿…è†€
            ctx.fillStyle = adjustBrightness(this.color, 0.8);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(
                -this.width / 4, wingY - this.height / 2 * wingScale, 
                -this.width / 2 * wingScale, wingY
            );
            ctx.quadraticCurveTo(
                -this.width / 4, wingY + this.height / 4, 
                0, 0
            );
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
    };
    
    birds.push(bird);
    
    return bird;
}
        
        // å¯åŠ¨æ¸¸æˆ
        function startGame() {
            if (wordList.length === 0) {
                alert('è¯·å…ˆå¯¼å…¥å•è¯è¡¨ï¼');
                return;
            }
            
            gameStarted = true;
            gameRunning = true;
            currentWordIndex = 0;
            visibleWordIndex = 0;
            score = 0;
            
            // é‡ç½®å¤©æ°”æ•ˆæœ
            resetWeatherEffects();
            
            // éšæœºé€‰æ‹©ä¸€ç§å¤©æ°”
            randomizeWeather();
            
            // é‡ç½®èƒŒè¯µæ¨¡å¼UI
            document.getElementById('wordArchive').style.display = 'none';
            wordArchiveVisible = false;
            document.getElementById('hintedWordsButton').style.display = studyMode ? 'flex' : 'none';
            
            // æ›´æ–°è¿›åº¦æ˜¾ç¤º
            updateProgressBar();
            
            // é‡ç½®ç©å®¶ä½ç½®
            player.x = 100;
            player.y = gameHeight / 2;
            player.velY = 0;
            player.isJumping = false;
            
            // é‡ç½®ç›¸æœº
            camera.x = 0;
            camera.y = 0;
            
            // æ¸…é™¤ç°æœ‰æ¸¸æˆå¯¹è±¡
            gameObjects.length = 0;
            platforms.length = 0;
            jumpboards.length = 0;
            birds.length = 0;
            ducks.length = 0;
            ponds.length = 0;
            if (window.specialPlatforms) window.specialPlatforms.length = 0;
            if (window.hazards) window.hazards.length = 0;
            
            // ç”Ÿæˆæ¸¸æˆå…³å¡
            generateLevel();
            
            // å¯åŠ¨æ¸¸æˆå¾ªç¯
            lastTime = performance.now();
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // éšæœºé€‰æ‹©å¤©æ°”æ•ˆæœ
        function randomizeWeather() {
            // 33% æ¦‚ç‡å‡ºç°ç‰¹æ®Šå¤©æ°”
            if (Math.random() < 0.33) {
                const weatherTypes = ["lightning", "sandstorm", "rainbow"];
                const selectedWeather = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
                
                switch(selectedWeather) {
                    case "lightning":
                        activateLightning();
                        break;
                    case "sandstorm":
                        activateSandstorm();
                        break;
                    case "rainbow":
                        activateRainbow();
                        break;
                }
            }
        }
        
        // æ¿€æ´»é—ªç”µæ•ˆæœ
        function activateLightning() {
            console.log("æ¿€æ´»é—ªç”µæ•ˆæœ");
            weatherEffects.lightning.active = true;
            weatherEffects.lightning.lastFlash = 0;
            weatherEffects.lightning.nextFlash = Math.random() * 5000 + 2000; // 2-7ç§’åçš„ç¬¬ä¸€æ¬¡é—ªç”µ
            weatherEffects.lightning.opacity = 0;
        }
        
        // æ¿€æ´»æ²™å°˜æš´æ•ˆæœ
        function activateSandstorm() {
            console.log("æ¿€æ´»æ²™å°˜æš´æ•ˆæœ");
            weatherEffects.sandstorm.active = true;
            weatherEffects.sandstorm.intensity = 0;
            weatherEffects.sandstorm.particles = [];
            
            // åˆ›å»ºåˆå§‹æ²™å°˜ç²’å­
            for (let i = 0; i < 100; i++) {
                addSandParticle();
            }
        }
        
        // æ¿€æ´»å½©è™¹æ•ˆæœ
        function activateRainbow() {
            console.log("æ¿€æ´»å½©è™¹æ•ˆæœ");
            weatherEffects.rainbow.active = true;
            weatherEffects.rainbow.opacity = 0;
            
            // æ¸å˜æ˜¾ç¤ºå½©è™¹
            document.getElementById('rainbow').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('rainbow').style.opacity = '1';
            }, 1000);
        }
        
        // æ·»åŠ æ²™å°˜ç²’å­
        function addSandParticle() {
            weatherEffects.sandstorm.particles.push({
                x: camera.x + Math.random() * gameWidth * 1.2 - gameWidth * 0.1,
                y: camera.y + Math.random() * gameHeight,
                size: 1 + Math.random() * 3,
                speed: 5 + Math.random() * 10,
                opacity: 0.3 + Math.random() * 0.5,
                color: `rgb(${210 + Math.random() * 30}, ${175 + Math.random() * 20}, ${140 + Math.random() * 20})`
            });
        }
        
        // åˆ›å»ºèŠ±æœµ
        function createFlower(x, groundY) {
            const colors = getSeasonColor('flowers');
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            
            const flower = {
                x: x,
                y: groundY - 30,
                width: 20,
                height: 30,
                type: 'decoration',
                color: randomColor,
                swayOffset: Math.random() * Math.PI * 2, // éšæœºæ‘†åŠ¨åç§»
                draw: function(ctx) {
                    // è®¡ç®—æ‘†åŠ¨è§’åº¦
                    const swayAngle = Math.sin(gameTime * 0.001 + this.swayOffset) * 0.1;
                    
                    ctx.save();
                    ctx.translate(this.x + 10, this.y + 30);
                    ctx.rotate(swayAngle);
                    ctx.translate(-(this.x + 10), -(this.y + 30));
                    
                    // ç»˜åˆ¶èŒ
                    ctx.strokeStyle = '#7d6445';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x + 10, this.y + 30);
                    ctx.lineTo(this.x + 10, this.y + 10);
                    ctx.stroke();
                    
                    // ç»˜åˆ¶èŠ±ç“£
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2;
                        const petalX = this.x + 10 + Math.cos(angle) * 8;
                        const petalY = this.y + 10 + Math.sin(angle) * 8;
                        ctx.lineTo(petalX, petalY);
                        
                        const midAngle = ((i + 0.5) / 5) * Math.PI * 2;
                        const midX = this.x + 10 + Math.cos(midAngle) * 4;
                        const midY = this.y + 10 + Math.sin(midAngle) * 4;
                        ctx.lineTo(midX, midY);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // ç»˜åˆ¶èŠ±å¿ƒ
                    ctx.fillStyle = '#ffbe0b';
                    ctx.beginPath();
                    ctx.arc(this.x + 10, this.y + 10, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            };
            
            gameObjects.push(flower);
        }

        // åˆ›å»ºçŒæœ¨ä¸›
        function createBush(x, groundY) {
            const bush = {
                x: x,
                y: groundY - 30,
                width: 50 + Math.random() * 30,
                height: 30 + Math.random() * 20,
                type: 'decoration',
                draw: function(ctx) {
                    const bushColor = getSeasonColor('trees');
                    ctx.fillStyle = bushColor;
                    
                    // ç»˜åˆ¶å‡ ä¸ªé‡å çš„åœ†å½¢æ¥åˆ›å»ºçŒæœ¨ä¸›
                    ctx.beginPath();
                    ctx.arc(this.x + this.width * 0.3, this.y + this.height * 0.7, this.width * 0.3, 0, Math.PI * 2);
                    ctx.arc(this.x + this.width * 0.7, this.y + this.height * 0.7, this.width * 0.3, 0, Math.PI * 2);
                    ctx.arc(this.x + this.width * 0.5, this.y + this.height * 0.3, this.width * 0.4, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.fill();
                }
            };
            
            gameObjects.push(bush);
        }
        
        // åˆ›å»ºæ‚¬å´–
        function createCliff(x, groundY) {
            const cliffWidth = 150 + Math.random() * 100;
            
            // åœ¨æ‚¬å´–ä¸Šæ·»åŠ å¹³å°
            const platformY = groundY - 150 - Math.random() * 50;
            const platform = {
                x: x + cliffWidth * 0.1,
                y: platformY,
                width: cliffWidth * 0.8,
                height: 20,
                type: 'platform',
                color: '#a38560'
            };
            
            platforms.push(platform);
            gameObjects.push(platform);
            
            // åˆ›å»ºæ‚¬å´–éšœç¢ç‰©
            const cliff = {
                x: x,
                y: platformY + 20,
                width: cliffWidth,
                height: groundY - platformY,
                type: 'obstacle',
                draw: function(ctx) {
                    // ç»˜åˆ¶æ‚¬å´–
                    const gradient = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.height);
                    gradient.addColorStop(0, '#a38560');
                    gradient.addColorStop(1, '#7d6445');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + this.width, this.y);
                    ctx.lineTo(this.x + this.width, this.y + this.height);
                    ctx.lineTo(this.x, this.y + this.height);
                    ctx.closePath();
                    ctx.fill();
                    
                    // ç»˜åˆ¶çº¹ç†
                    ctx.strokeStyle = '#65532f';
                    ctx.lineWidth = 1;
                    
                    for (let i = 1; i < 10; i++) {
                        const lineY = this.y + this.height * (i / 10);
                        ctx.beginPath();
                        ctx.moveTo(this.x, lineY);
                        ctx.lineTo(this.x + this.width, lineY + Math.sin(i) * 10);
                        ctx.stroke();
                    }
                }
            };
            
            gameObjects.push(cliff);
        }
        
        // åˆ›å»ºè—¤è”“
        function createVine(x, startY) {
            const vineLength = 200 + Math.random() * 100;
            
            const vine = {
                x: x,
                y: startY,
                width: 10,
                height: vineLength,
                type: 'decoration',
                swayOffset: Math.random() * Math.PI * 2, // éšæœºæ‘†åŠ¨åç§»
                draw: function(ctx) {
                    // è®¡ç®—æ‘†åŠ¨
                    const swayAmount = 20;
                    const swayFrequency = 0.001;
                    
                    ctx.strokeStyle = getSeasonColor('trees');
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    
                    let lastX = this.x;
                    ctx.moveTo(lastX, this.y);
                    
                    for (let y = 20; y < this.height; y += 20) {
                        const sway = Math.sin(gameTime * swayFrequency + this.swayOffset + y * 0.01) * swayAmount;
                        lastX = this.x + sway;
                        ctx.lineTo(lastX, this.y + y);
                    }
                    
                    ctx.stroke();
                    
                    // ç»˜åˆ¶å¶å­
                    ctx.fillStyle = getSeasonColor('trees');
                    
                    for (let y = 40; y < this.height; y += 80) {
                        const sway = Math.sin(gameTime * swayFrequency + this.swayOffset + y * 0.01) * swayAmount;
                        const leafX = this.x + sway;
                        const leafY = this.y + y;
                        
                        // å·¦ä¾§å¶å­
                        ctx.beginPath();
                        ctx.ellipse(leafX - 10, leafY, 15, 8, Math.PI / 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // å³ä¾§å¶å­
                        ctx.beginPath();
                        ctx.ellipse(leafX + 10, leafY, 15, 8, -Math.PI / 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                },
                // è—¤è”“å¯ä»¥å½“ä½œå¹³å°
                platformCheck: function(playerObj) {
                    // è®¡ç®—å½“å‰è—¤è”“çš„æ‘†åŠ¨ä½ç½®
                    const swayAmount = 20;
                    const swayFrequency = 0.001;
                    
                    // æ£€æŸ¥ç©å®¶æ˜¯å¦æ¥è§¦åˆ°è—¤è”“
                    for (let y = 0; y < this.height; y += 10) {
                        const sway = Math.sin(gameTime * swayFrequency + this.swayOffset + y * 0.01) * swayAmount;
                        const vineX = this.x + sway;
                        const vineY = this.y + y;
                        
                        const dx = Math.abs(vineX - (playerObj.x + playerObj.width / 2));
                        const dy = Math.abs(vineY - (playerObj.y + playerObj.height / 2));
                        
                        if (dx < 15 && dy < 30) {
                            return true;
                        }
                    }
                    
                    return false;
                }
            };
            
            gameObjects.push(vine);
            
            // å°†è—¤è”“æ·»åŠ åˆ°ç‰¹æ®Šå¹³å°æ£€æŸ¥æ•°ç»„
            if (!window.specialPlatforms) window.specialPlatforms = [];
            window.specialPlatforms.push(vine);
        }

        // é‡å¯æ¸¸æˆ
        function restartGame() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // é‡ç½®å¤©æ°”æ•ˆæœ
            resetWeatherEffects();
            
            // é‡ç½®å•è¯è®¿é—®çŠ¶æ€
            for (let i = 0; i < wordList.length; i++) {
                wordList[i].visited = false;
            }
            
            currentWordIndex = 0;
            visibleWordIndex = 0;
            score = 0;
            
            // æ¸…é™¤å¯èƒ½çš„æ´»åŠ¨å›¾æ ‡
            activeVolumeIcon = null;
            activeHintButton = null;
            document.getElementById('volumeIcon').style.display = 'none';
            document.getElementById('hintButton').style.display = 'none';
            
            startGame();
        }
        
        // ç”Ÿæˆæ¸¸æˆå…³å¡
        function generateLevel() {
            // ç”ŸæˆèƒŒæ™¯
            generateBackground();
            
            // ç”Ÿæˆåœ°é¢
            const ground = {
                x: 0,
                y: gameHeight - 50,
                width: gameWidth * 100, // å¾ˆé•¿çš„åœ°é¢
                height: 50,
                type: 'platform',
                color: getSeasonColor('ground')
            };
            platforms.push(ground);
            
            // å·¦ä¾§è¾¹ç•Œ - æ·»åŠ ä¸€ä¸ªé˜²æ­¢ç©å®¶æ‰è½çš„æŸ±å­
            const leftBoundary = {
                x: -50,
                y: 0,
                width: 50,
                height: gameHeight * 2,
                type: 'platform',
                draw: function(ctx) {
                    // ç»˜åˆ¶ä¸€ä¸ªåŠé€æ˜çš„å¢™ï¼Œä¸åœ°é¢é¢œè‰²ç›¸ä¼¼
                    const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y);
                    gradient.addColorStop(0, 'rgba(50, 50, 50, 0.8)');
                    gradient.addColorStop(1, 'rgba(80, 80, 80, 0.3)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    // æ·»åŠ ä¸€äº›çº¹ç†çº¿æ¡
                    ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                    ctx.lineWidth = 1;
                    
                    for (let i = 0; i < this.height; i += 50) {
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + i);
                        ctx.lineTo(this.x + this.width, this.y + i);
                        ctx.stroke();
                    }
                }
            };
            platforms.push(leftBoundary);
            gameObjects.push(leftBoundary);
            
            // ä¸ºæ¯ä¸ªå•è¯åˆ›å»ºå¹³å°å’Œéšœç¢ç‰©
            let lastX = 300; // èµ·å§‹Xä½ç½®
            const platformHeight = gameHeight - 50; // åœ°é¢é«˜åº¦
            
            // æ·»åŠ è£…é¥°ç‰©å’ŒåŠ¨æ€å…ƒç´ 
            addDecorations(lastX, platformHeight);
            
            // åˆå§‹åŒ–ç‰¹æ®Šå¹³å°æ•°ç»„å’Œå±é™©åŒºåŸŸæ•°ç»„
            if (!window.specialPlatforms) window.specialPlatforms = [];
            window.specialPlatforms.length = 0;
            
            if (!window.hazards) window.hazards = [];
            window.hazards.length = 0;
            
            jumpboards.length = 0;
            
            for (let i = 0; i < wordList.length; i++) {
                const word = wordList[i];
                const isEnglishDisplay = Math.random() > 0.5; // éšæœºæ˜¾ç¤ºè‹±æ–‡æˆ–ä¸­æ–‡
                const distance = 300 + Math.random() * 200; // å¹³å°ä¹‹é—´çš„è·ç¦»
                
                lastX += distance;
                
                // éšæœºå†³å®šç‰©ä½“ç±»å‹
                const objectType = Math.floor(Math.random() * 3);
                
                if (objectType === 0) {
                    // å²©çŸ³
                    createRock(lastX, platformHeight, word, isEnglishDisplay);
                } else if (objectType === 1) {
                    // å°é˜¶
                    createStairs(lastX, platformHeight, word, isEnglishDisplay);
                } else {
                    // æ¤ç‰©
                    createPlant(lastX, platformHeight, word, isEnglishDisplay);
                }
                
                // æ¯éš”å‡ ä¸ªå•è¯æ·»åŠ ä¸€äº›è£…é¥°ç‰©
                if (i % 3 === 0) {
                    addDecorations(lastX + 150, platformHeight);
                }
                
                // éšæœºæ·»åŠ éšœç¢ç‰©ï¼ˆå°–åˆºå‘æˆ–è†æ£˜ï¼‰
                if (i % 4 === 0) {
                    if (Math.random() > 0.5) {
                        createHiddenPit(lastX - 150, platformHeight);
                    } else {
                        createThorns(lastX - 150, platformHeight - 30, 80);
                    }
                }
                
                // æ¯éš”ä¸€å®šè·ç¦»æ·»åŠ åŠ¨æ€æ•Œäºº
                if (i % 5 === 0) {
                    createCrab(lastX + Math.random() * 100 - 50, platformHeight);
                }
                
                // åœ°é¢ä¸‹æ–¹çš„æ”¶é›†åŒº
                if (i % 6 === 1) {
                    // åˆ›å»ºä¸€ä¸ªç©ºæ´
                    createHiddenHole(lastX - 200, platformHeight, 180);
                    
                    // åœ¨æ´ä¸‹é¢æ”¾ç½®ä¸€äº›è£…é¥°ç‰©
                    createDecorationsUnderground(lastX - 100, platformHeight + 150);
                }
                
                // éšæœºæ·»åŠ è·³æ¿
                if (i % 7 === 0) {
                    createJumpboard(lastX - 100, platformHeight - 20);
                }
                
                // éšæœºæ·»åŠ æ± å¡˜
                if (i % 8 === 0 && Math.random() > 0.5) {
                    lastX += 150; // ä¸ºæ± å¡˜è…¾å‡ºç©ºé—´
                    createPond(lastX, platformHeight);
                    lastX += 250; // æ± å¡˜ä¹‹åçš„è·ç¦»
                }
            }
            
            // æ·»åŠ ç»ˆç‚¹æ ‡å¿—
            const finishFlag = {
                x: lastX + 500,
                y: platformHeight - 200,
                width: 50,
                height: 200,
                type: 'finish',
                color: '#ff5733'
            };
            
            gameObjects.push(finishFlag);
            
            // åˆå§‹åŒ–ç¯å¢ƒæ•ˆæœ
            initEnvironment();
        }
        
        // è·å–å½“å‰å­£èŠ‚é¢œè‰²
        function getSeasonColor(type) {
            if (!seasonChangeStarted) {
                return seasonColors[currentSeason][type];
            }
            
            // æ­£åœ¨å­£èŠ‚è¿‡æ¸¡ä¸­ï¼Œæ··åˆä¸¤ä¸ªå­£èŠ‚çš„é¢œè‰²
            const currentColor = seasonColors[currentSeason][type];
            const nextColor = seasonColors[nextSeason][type];
            
            // å¦‚æœæ˜¯æ•°ç»„ï¼ˆå¦‚èŠ±æœµé¢œè‰²ï¼‰ï¼Œåˆ™è¿”å›å½“å‰å­£èŠ‚çš„é¢œè‰²
            if (Array.isArray(currentColor)) {
                return seasonTransition > 0.5 ? nextColor : currentColor;
            }
            
            // å¦åˆ™æ··åˆé¢œè‰²
            return interpolateColor(currentColor, nextColor, seasonTransition);
        }
        
        // åˆ›å»ºåœ°ä¸‹è£…é¥°ç‰©
        function createDecorationsUnderground(x, y) {
            // æ·»åŠ éšæœºå²©çŸ³
            for (let i = 0; i < 3; i++) {
                const rockX = x + Math.random() * 150 - 75;
                const rockY = y + Math.random() * 100;
                
                const rock = {
                    x: rockX,
                    y: rockY,
                    width: 30 + Math.random() * 20,
                    height: 20 + Math.random() * 15,
                    type: 'decoration',
                    draw: function(ctx) {
                        ctx.fillStyle = '#555';
                        ctx.beginPath();
                        ctx.ellipse(
                            this.x + this.width/2, 
                            this.y + this.height/2, 
                            this.width/2, 
                            this.height/2, 
                            0, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                };
                
                gameObjects.push(rock);
            }
            
            // æ·»åŠ æ°´æ™¶
            for (let i = 0; i < 2; i++) {
                const crystalX = x + Math.random() * 150 - 75;
                const crystalY = y + Math.random() * 80;
                
                const crystal = {
                    x: crystalX,
                    y: crystalY,
                    width: 20,
                    height: 30,
                    type: 'decoration',
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                    draw: function(ctx) {
                        ctx.fillStyle = this.color;
                        
                        // å¤šè¾¹å½¢æ°´æ™¶
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width/2, this.y);
                        ctx.lineTo(this.x + this.width, this.y + this.height * 0.3);
                        ctx.lineTo(this.x + this.width * 0.7, this.y + this.height);
                        ctx.lineTo(this.x + this.width * 0.3, this.y + this.height);
                        ctx.lineTo(this.x + this.width * 0.3, this.y + this.height);
                        ctx.lineTo(this.x, this.y + this.height * 0.3);
                        ctx.closePath();
                        ctx.fill();
                        
                        // äº®ç‚¹
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.beginPath();
                        ctx.ellipse(
                            this.x + this.width * 0.3, 
                            this.y + this.height * 0.2,
                            2, 4, Math.PI/4, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                };
                
                gameObjects.push(crystal);
            }
        }
        
        // åˆ›å»ºéšè—å‘ - ä¼˜åŒ–å‘çš„è®¾è®¡
        // å®Œå…¨é‡å†™createHiddenPitå‡½æ•°
// å®Œå…¨é‡å†™createHiddenPitå‡½æ•°
function createHiddenPit(x, groundY) {
    // åˆ›å»ºå‘çš„ä¸¤ä¾§è¾¹ç¼˜
    const pitWidth = 120; // æ›´å®½çš„å‘
    
    // å·¦ä¾§è¾¹ç¼˜
    const leftEdge = {
        x: x,
        y: groundY,
        width: 30, // æ›´å®½çš„è¾¹ç¼˜
        height: 60, // æ›´æ·±çš„å‘
        type: 'platform',
        color: getSeasonColor('ground'),
        draw: function(ctx) {
            // ç»˜åˆ¶å·¦ä¾§è¾¹ç¼˜ï¼Œå’Œåœ°å½¢èåˆ
            const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y);
            gradient.addColorStop(0, getSeasonColor('ground'));
            gradient.addColorStop(1, adjustBrightness(getSeasonColor('ground'), 0.9));
            
            ctx.fillStyle = gradient;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            
            // æ·»åŠ ä¸€äº›è‰æˆ–é›ª
            ctx.fillStyle = adjustBrightness(getSeasonColor('ground'), 1.1);
            for (let i = 0; i < 5; i++) {
                const grassHeight = 3 + Math.random() * 5;
                ctx.fillRect(this.x + Math.random() * this.width, this.y - grassHeight, 2, grassHeight);
            }
            
            // æ·»åŠ ä¸€äº›æŒ‡ç¤ºæ€§æ ‡å¿— - å¦‚æ›´æš—çš„è¾¹ç¼˜
            ctx.strokeStyle = '#a61e4d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.x + this.width - 5, this.y - 5);
            ctx.lineTo(this.x + this.width, this.y);
            ctx.lineTo(this.x + this.width, this.y + 10);
            ctx.stroke();
        }
    };
    
    // å³ä¾§è¾¹ç¼˜
    const rightEdge = {
        x: x + pitWidth - 30,
        y: groundY,
        width: 30, // æ›´å®½çš„è¾¹ç¼˜
        height: 60, // æ›´æ·±çš„å‘
        type: 'platform',
        color: getSeasonColor('ground'),
        draw: function(ctx) {
            // ç»˜åˆ¶å³ä¾§è¾¹ç¼˜ï¼Œå’Œåœ°å½¢èåˆ
            const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y);
            gradient.addColorStop(0, adjustBrightness(getSeasonColor('ground'), 0.9));
            gradient.addColorStop(1, getSeasonColor('ground'));
            
            ctx.fillStyle = gradient;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            
            // æ·»åŠ ä¸€äº›è‰æˆ–é›ª
            ctx.fillStyle = adjustBrightness(getSeasonColor('ground'), 1.1);
            for (let i = 0; i < 5; i++) {
                const grassHeight = 3 + Math.random() * 5;
                ctx.fillRect(this.x + Math.random() * this.width, this.y - grassHeight, 2, grassHeight);
            }
            
            // æ·»åŠ ä¸€äº›æŒ‡ç¤ºæ€§æ ‡å¿— - å¦‚æ›´æš—çš„è¾¹ç¼˜
            ctx.strokeStyle = '#a61e4d';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.x + 5, this.y - 5);
            ctx.lineTo(this.x, this.y);
            ctx.lineTo(this.x, this.y + 10);
            ctx.stroke();
        }
    };
    
    // å‘åº• - ç¡®ä¿ç©å®¶èƒ½èµ°è¿‡
    const bottom = {
        x: x + 30,
        y: groundY + 60, // å‘åº•éƒ¨
        width: pitWidth - 60,
        height: 20,
        type: 'platform',
        draw: function(ctx) {
            ctx.fillStyle = adjustBrightness(getSeasonColor('ground'), 0.7);
            ctx.fillRect(this.x, this.y, this.width, this.height);
            
            // æ·»åŠ ä¸€äº›çº¹ç†
            ctx.strokeStyle = adjustBrightness(getSeasonColor('ground'), 0.5);
            ctx.lineWidth = 1;
            for (let i = 0; i < this.width; i += 10) {
                ctx.beginPath();
                ctx.moveTo(this.x + i, this.y);
                ctx.lineTo(this.x + i, this.y + 5);
                ctx.stroke();
            }
        }
    };
    
    // åœ¨å‘ä¸­é—´æ·»åŠ è·³æ¿ï¼Œå¸®åŠ©ç©å®¶ä¸Šæ¥
    const jumpboard = {
        x: x + pitWidth/2 - 30,
        y: groundY + 30, // å‘ä¸­é—´é«˜åº¦
        type: 'jumpboard',
        width: 60,
        height: 20,
        compressed: false,
        animationTime: 0,
        jumpMultiplier: 1.8,
        draw: function(ctx) {
            // ç»˜åˆ¶ä¸€ä¸ªè§†è§‰ä¸Šæ˜æ˜¾çš„è·³æ¿
            const boardColor = currentSeason === 'winter' ? '#B0BEC5' : '#8D6E63';
            
            const compressionAmount = this.compressed ? 
                5 * (1 - Math.sin(this.animationTime * Math.PI)) : 0;
            
            // åº•éƒ¨æ”¯æ¶
            ctx.fillStyle = '#555';
            ctx.fillRect(this.x + this.width/2 - 8, this.y + 15 + compressionAmount, 16, 5);
            
            // å¼¹ç°§
            const springHeight = 8 - compressionAmount;
            ctx.strokeStyle = '#FF6B6B';
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.moveTo(this.x + this.width/2 - 5, this.y + 15 + compressionAmount);
            ctx.lineTo(this.x + this.width/2 - 2, this.y + 12 + compressionAmount - springHeight/2);
            ctx.lineTo(this.x + this.width/2 + 2, this.y + 18 + compressionAmount - springHeight);
            ctx.lineTo(this.x + this.width/2 + 5, this.y + 15 + compressionAmount);
            ctx.stroke();
            
            // æœ¨æ¿
            ctx.fillStyle = boardColor;
            const boardY = this.y - 3 + compressionAmount;
            
            ctx.beginPath();
            ctx.moveTo(this.x, boardY + 5);
            ctx.quadraticCurveTo(
                this.x + this.width/2, boardY, 
                this.x + this.width, boardY + 5
            );
            ctx.lineTo(this.x + this.width, boardY + 12);
            ctx.quadraticCurveTo(
                this.x + this.width/2, boardY + 18,
                this.x, boardY + 12
            );
            ctx.closePath();
            ctx.fill();
            
            // æœ¨çº¹
            ctx.strokeStyle = adjustBrightness(boardColor, 0.7);
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                const lineY = boardY + 5 + i * 3;
                ctx.beginPath();
                ctx.moveTo(this.x + 5, lineY);
                ctx.quadraticCurveTo(
                    this.x + this.width/2, lineY + (i % 2 === 0 ? 2 : -1),
                    this.x + this.width - 5, lineY
                );
                ctx.stroke();
            }
        },
        update: function(deltaTime) {
            // æ›´æ–°åŠ¨ç”»
            if (this.compressed) {
                this.animationTime += deltaTime * 0.01;
                if (this.animationTime > 1) {
                    this.compressed = false;
                    this.animationTime = 0;
                }
            }
            return true; // å§‹ç»ˆè¿”å›trueç¡®ä¿è·³æ¿ä¸ä¼šè¢«ç§»é™¤
        },
        checkInteraction: function(playerObj) {
            if (playerObj.velY > 0 && 
                playerObj.x + playerObj.width > this.x + 5 &&
                playerObj.x < this.x + this.width - 5 &&
                playerObj.y + playerObj.height > this.y - 5 &&
                playerObj.y + playerObj.height < this.y + this.height/2) {
                
                this.compressed = true;
                this.animationTime = 0;
                
                playerObj.velY = -playerObj.jumpForce * this.jumpMultiplier;
                playerObj.isJumping = true;
                
                return true;
            }
            return false;
        }
    };
    
    // å…³é”®éƒ¨åˆ†ï¼šç§»é™¤å‘ä¸Šæ–¹çš„groundå¹³å°
    // æ‰¾åˆ°æ¸¸æˆä¸­çš„åœ°é¢å¹³å°
    for (let i = 0; i < platforms.length; i++) {
        const platform = platforms[i];
        // å¦‚æœæ˜¯ä¸»åœ°é¢å¹³å°(æœ€é•¿çš„é‚£ä¸ª)
        if (platform.width > gameWidth * 50) {
            // ä¿®æ”¹å¹³å°ï¼Œåœ¨å‘çš„ä½ç½®æŒ–ä¸€ä¸ªæ´
            platform.draw = function(ctx) {
                ctx.fillStyle = this.color || getSeasonColor('ground');
                
                // ç»˜åˆ¶åœ°é¢ï¼Œä½†åœ¨å‘çš„ä½ç½®ç•™ç©º
                ctx.fillRect(this.x, this.y, x - this.x, this.height); // å‘å·¦è¾¹
                ctx.fillRect(x + pitWidth, this.y, this.x + this.width - (x + pitWidth), this.height); // å‘å³è¾¹
            };
            break;
        }
    }
    
    // æ·»åŠ æ‰€æœ‰å…ƒç´ åˆ°æ¸¸æˆä¸­
    platforms.push(leftEdge);
    platforms.push(rightEdge);
    platforms.push(bottom);
    gameObjects.push(leftEdge);
    gameObjects.push(rightEdge);
    gameObjects.push(bottom);
    gameObjects.push(jumpboard);
    jumpboards.push(jumpboard);
}
        
        // åˆ›å»ºéšè—æ´ - çœ‹èµ·æ¥åƒæ™®é€šåœ°å½¢çš„æ´
        function createHiddenHole(x, groundY, width) {
            // åˆ›å»ºæ´çš„ä¸¤ä¾§è¾¹ç¼˜
            const leftEdge = {
                x: x,
                y: groundY,
                width: 20,
                height: 300, // è¶³å¤Ÿæ·±
                type: 'platform',
                draw: function(ctx) {
                    // å·¦ä¾§é™¡å³­ä½†ä¸åœ°é¢èåˆçš„è¾¹ç¼˜
                    const groundColor = getSeasonColor('ground');
                    const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y);
                    gradient.addColorStop(0, groundColor);
                    gradient.addColorStop(1, adjustBrightness(groundColor, 0.7));
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    // æ·»åŠ ä¸€äº›è‰æˆ–è£…é¥°
                    if (currentSeason !== 'winter') {
                        ctx.fillStyle = adjustBrightness(groundColor, 1.2);
                        for (let i = 0; i < 4; i++) {
                            const grassHeight = 3 + Math.random() * 5;
                            ctx.fillRect(this.x + this.width - 5 + Math.random() * 5, 
                                         this.y - grassHeight, 2, grassHeight);
                        }
                    }
                    
                    // æ‚¬æŒ‚çš„è—¤è”“æˆ–å†°æŸ±
                    const vineColor = currentSeason === 'winter' ? '#E1F5FE' : '#8BC34A';
                    ctx.strokeStyle = vineColor;
                    ctx.lineWidth = 2;
                    
                    for (let i = 0; i < 2; i++) {
                        const startX = this.x + 5 + i * 10;
                        const length = 30 + Math.random() * 50;
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, this.y);
                        
                        // å¼¯æ›²çš„è—¤è”“
                        const cp1x = startX - 5;
                        const cp1y = this.y + length * 0.4;
                        const cp2x = startX + 5;
                        const cp2y = this.y + length * 0.8;
                        const endX = startX;
                        const endY = this.y + length;
                        
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                        ctx.stroke();
                    }
                }
            };
            
            const rightEdge = {
                x: x + width - 20,
                y: groundY,
                width: 20,
                height: 300, // è¶³å¤Ÿæ·±
                type: 'platform',
                draw: function(ctx) {
                    // å³ä¾§é™¡å³­ä½†ä¸åœ°é¢èåˆçš„è¾¹ç¼˜
                    const groundColor = getSeasonColor('ground');
                    const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y);
                    gradient.addColorStop(0, adjustBrightness(groundColor, 0.7));
                    gradient.addColorStop(1, groundColor);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    // æ·»åŠ ä¸€äº›è‰æˆ–è£…é¥°
                    if (currentSeason !== 'winter') {
                        ctx.fillStyle = adjustBrightness(groundColor, 1.2);
                        for (let i = 0; i < 4; i++) {
                            const grassHeight = 3 + Math.random() * 5;
                            ctx.fillRect(this.x + Math.random() * 5, 
                                         this.y - grassHeight, 2, grassHeight);
                        }
                    }
                    
                    // æ‚¬æŒ‚çš„è—¤è”“æˆ–å†°æŸ±
                    const vineColor = currentSeason === 'winter' ? '#E1F5FE' : '#8BC34A';
                    ctx.strokeStyle = vineColor;
                    ctx.lineWidth = 2;
                    
                    for (let i = 0; i < 2; i++) {
                        const startX = this.x + 5 + i * 10;
                        const length = 20 + Math.random() * 40;
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, this.y);
                        
                        // å¼¯æ›²çš„è—¤è”“
                        const cp1x = startX - 5;
                        const cp1y = this.y + length * 0.3;
                        const cp2x = startX + 5;
                        const cp2y = this.y + length * 0.6;
                        const endX = startX;
                        const endY = this.y + length;
                        
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                        ctx.stroke();
                    }
                }
            };
            
            // æ´åº•éƒ¨å¹³å°
            const bottom = {
                x: x + 20,
                y: groundY + 250,
                width: width - 40,
                height: 50,
                type: 'platform',
                draw: function(ctx) {
                    // åœ°ä¸‹æ´ç©´åœ°æ¿
                    const groundColor = adjustBrightness(getSeasonColor('ground'), 0.6);
                    ctx.fillStyle = groundColor;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    // æ·»åŠ çº¹ç†
                    ctx.strokeStyle = adjustBrightness(groundColor, 0.8);
                    ctx.lineWidth = 1;
                    
                    for (let i = 0; i < this.width; i += 10) {
                        ctx.beginPath();
                        ctx.moveTo(this.x + i, this.y);
                        ctx.lineTo(this.x + i, this.y + 5);
                        ctx.stroke();
                    }
                    
                    // æ·»åŠ ä¸€äº›å°çŸ³å¤´æˆ–ç»“æ™¶
                    for (let i = 0; i < 5; i++) {
                        const rockSize = 3 + Math.random() * 5;
                        const rockX = this.x + Math.random() * this.width;
                        
                        ctx.fillStyle = '#555';
                        ctx.beginPath();
                        ctx.arc(rockX, this.y - rockSize/2, rockSize/2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            };
            
            platforms.push(leftEdge);
            platforms.push(rightEdge);
            platforms.push(bottom);
            
            gameObjects.push(leftEdge);
            gameObjects.push(rightEdge);
            gameObjects.push(bottom);
        }
        
        // åˆ›å»ºè·³æ¿ - æ”¹è¿›ä¸ºä¸æ¶ˆå¤±
   // ä¿®æ”¹createJumpboardå‡½æ•°
function createJumpboard(x, y) {
    const jumpboard = {
        x: x,
        y: y,
        width: 60,
        height: 20,
        type: 'jumpboard',
        compressed: false,
        animationTime: 0,
        jumpMultiplier: 1.4, // è·³æ¿å¼¹è·³åŠ›æ˜¯æ­£å¸¸è·³è·ƒçš„1.4å€
        lastJumpTime: 0, // è®°å½•ä¸Šæ¬¡è·³è·ƒæ—¶é—´
        checkInteraction: function(playerObj) {
            // æ”¹è¿›çš„ç¢°æ’æ£€æµ‹
            if (playerObj.velY > 0 && // ç©å®¶æ­£åœ¨ä¸‹è½
                playerObj.x + playerObj.width > this.x + 5 &&
                playerObj.x < this.x + this.width - 5 &&
                playerObj.y + playerObj.height >= this.y - 5 &&
                playerObj.y + playerObj.height <= this.y + 10) {
                
                // ç¡®ä¿è·³æ¿æ¯æ¬¡éƒ½ä¼šå‹ç¼©
                this.compressed = true;
                this.animationTime = 0;
                this.lastJumpTime = gameTime;
                
                // ç©å®¶å¼¹è·³
                playerObj.velY = -playerObj.jumpForce * this.jumpMultiplier;
                playerObj.isJumping = true;
                
                return true;
            }
            return false;
        },
        update: function(deltaTime) {
            // æ›´æ–°åŠ¨ç”»
            if (this.compressed) {
                this.animationTime += deltaTime * 0.01;
                if (this.animationTime > 1) {
                    this.compressed = false;
                }
            }
            return true; // ç¡®ä¿è·³æ¿ä¸ä¼šæ¶ˆå¤±
        },
        draw: function(ctx) {
            // æ ¹æ®å½“å‰å­£èŠ‚ç»˜åˆ¶è·³æ¿
            const boardColor = currentSeason === 'winter' ? '#B0BEC5' : '#8D6E63'; // å†¬å­£æ˜¯æµ…ç°è‰²ï¼Œå…¶ä»–å­£èŠ‚æ˜¯æœ¨è‰²
            
            // è®¡ç®—å‹ç¼©çŠ¶æ€
            const compressionAmount = this.compressed ? 
                5 * (1 - Math.sin(this.animationTime * Math.PI)) : 0;
            
            // ç»˜åˆ¶åº•éƒ¨æ”¯æ¶ï¼ˆå¼¹ç°§ï¼‰
            ctx.fillStyle = '#555';
            ctx.fillRect(this.x + this.width/2 - 8, this.y + 15 + compressionAmount, 16, 5);
            
            // ç»˜åˆ¶å¼¹ç°§
            const springHeight = 8 - compressionAmount;
            ctx.strokeStyle = '#FF6B6B';
            ctx.lineWidth = 3;
            
            // ç»˜åˆ¶å¼¹ç°§çš„é”¯é½¿å½¢çŠ¶
            ctx.beginPath();
            ctx.moveTo(this.x + this.width/2 - 5, this.y + 15 + compressionAmount);
            ctx.lineTo(this.x + this.width/2 - 2, this.y + 12 + compressionAmount - springHeight/2);
            ctx.lineTo(this.x + this.width/2 + 2, this.y + 18 + compressionAmount - springHeight);
            ctx.lineTo(this.x + this.width/2 + 5, this.y + 15 + compressionAmount);
            ctx.stroke();
            
            // ç»˜åˆ¶æœ¨æ¿
            ctx.fillStyle = boardColor;
            // ç»˜åˆ¶ç•¥å¾®å¼¯æ›²çš„æœ¨æ¿
            const boardY = this.y - 3 + compressionAmount;
            
            ctx.beginPath();
            ctx.moveTo(this.x, boardY + 5);
            ctx.quadraticCurveTo(
                this.x + this.width/2, boardY, 
                this.x + this.width, boardY + 5
            );
            ctx.lineTo(this.x + this.width, boardY + 12);
            ctx.quadraticCurveTo(
                this.x + this.width/2, boardY + 18,
                this.x, boardY + 12
            );
            ctx.closePath();
            ctx.fill();
            
            // ç»˜åˆ¶æœ¨çº¹
            ctx.strokeStyle = adjustBrightness(boardColor, 0.7);
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                const lineY = boardY + 5 + i * 3;
                ctx.beginPath();
                ctx.moveTo(this.x + 5, lineY);
                ctx.quadraticCurveTo(
                    this.x + this.width/2, lineY + (i % 2 === 0 ? 2 : -1),
                    this.x + this.width - 5, lineY
                );
                ctx.stroke();
            }
        }
    };
    
    jumpboards.push(jumpboard);
    gameObjects.push(jumpboard);
}
        // åˆ›å»ºè†æ£˜
        function createThorns(x, y, width) {
            const thorns = {
                x: x,
                y: y,
                width: width,
                height: 30,
                type: 'hazard',
                draw: function(ctx) {
                    // ç»˜åˆ¶è†æ£˜åº•éƒ¨
                    ctx.fillStyle = '#3a5a40';
                    ctx.fillRect(this.x, this.y + 20, this.width, 10);
                    
                    // ç»˜åˆ¶è†æ£˜å°–åˆº
                    ctx.fillStyle = '#a61e4d';
                    const thornCount = Math.floor(this.width / 8);
                    
                    for (let i = 0; i < thornCount; i++) {
                        const thornX = this.x + 4 + i * 8;
                        
                        // ä¸Šé¢çš„å°å°–åˆº
                        ctx.beginPath();
                        ctx.moveTo(thornX, this.y + 20);
                        ctx.lineTo(thornX - 3, this.y + 10);
                        ctx.lineTo(thornX + 3, this.y + 10);
                        ctx.closePath();
                        ctx.fill();
                        
                        // å¤§å°–åˆºï¼ˆäº¤é”™æ’åˆ—ï¼‰
                        if (i % 2 === 0) {
                            ctx.beginPath();
                            ctx.moveTo(thornX, this.y + 20);
                            ctx.lineTo(thornX - 4, this.y);
                            ctx.lineTo(thornX + 4, this.y);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                },
                // è†æ£˜ç¢°æ’æ£€æµ‹
                checkHazard: function(playerObj) {
                    if (checkCollision(playerObj, this)) {
                        // ç©å®¶ç¢°åˆ°è†æ£˜
                        
                        // æ°´å¹³æ–¹å‘æ¨å›
                        if (playerObj.x + playerObj.width / 2 < this.x + this.width / 2) {
                            playerObj.x -= 30; // å‘å·¦æ¨
                        } else {
                            playerObj.x += 30; // å‘å³æ¨
                        }
                        
                        return true;
                    }
                    return false;
                }
            };
            
            gameObjects.push(thorns);
            
            // å°†è†æ£˜æ·»åŠ åˆ°å±é™©åŒºåŸŸæ£€æŸ¥
            if (!window.hazards) window.hazards = [];
            window.hazards.push(thorns);
        }
        
        // åˆ›å»ºèƒèŸ¹æ•Œäºº
        function createCrab(x, groundY) {
            const crab = {
                x: x,
                y: groundY - 30,
                width: 40,
                height: 30,
                type: 'enemy',
                direction: Math.random() > 0.5 ? 1 : -1, // éšæœºåˆå§‹æ–¹å‘
                speed: 1 + Math.random(),
                moveRange: 100 + Math.random() * 100,
                startX: x,
                legPhase: 0,
                updateBehavior: function(deltaTime) {
                    // åœ¨ä¸€å®šèŒƒå›´å†…å·¦å³ç§»åŠ¨
                    this.x += this.direction * this.speed;
                    this.legPhase += deltaTime * 0.01;
                    
                    // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ç§»åŠ¨èŒƒå›´è¾¹ç•Œ
                    if (this.x > this.startX + this.moveRange || this.x < this.startX - this.moveRange) {
                        this.direction *= -1; // æ”¹å˜æ–¹å‘
                    }
                    
                    // æ£€æŸ¥ä¸ç©å®¶çš„ç¢°æ’
                    if (checkCollision(player, this)) {
                        // å¦‚æœç©å®¶ä»ä¸Šæ–¹è¸©åˆ°èƒèŸ¹
                        if (player.velY > 0 && player.y + player.height < this.y + this.height / 2) {
                            // ç§»é™¤èƒèŸ¹
                            const index = gameObjects.indexOf(this);
                            if (index > -1) {
                                gameObjects.splice(index, 1);
                            }
                            
                            // ç©å®¶å¼¹è·³
                            player.velY = -player.jumpForce * 0.7;
                        } else {
                            // ç©å®¶è¢«å‡»é€€
                            player.x += (player.x < this.x) ? -30 : 30;
                        }
                    }
                },
                draw: function(ctx) {
                    ctx.save();
                    
                    // æ ¹æ®ç§»åŠ¨æ–¹å‘ç¿»è½¬
                    if (this.direction < 0) {
                        ctx.translate(this.x + this.width, this.y);
                        ctx.scale(-1, 1);
                        ctx.translate(-this.width, 0);
                    } else {
                        ctx.translate(this.x, this.y);
                    }
                    
                    // èº«ä½“
                    ctx.fillStyle = '#e63946';
                    ctx.beginPath();
                    ctx.ellipse(this.width / 2, this.height / 2, this.width / 2 - 5, this.height / 2 - 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // çœ¼ç›
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.width / 2 + 8, this.height / 2 - 5, 4, 0, Math.PI * 2);
                    ctx.arc(this.width / 2 + 15, this.height / 2 - 5, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.width / 2 + 8, this.height / 2 - 5, 2, 0, Math.PI * 2);
                    ctx.arc(this.width / 2 + 15, this.height / 2 - 5, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // é’³å­
                    ctx.strokeStyle = '#e63946';
                    ctx.lineWidth = 3;
                    
                    // å·¦é’³å­
                    ctx.beginPath();
                    ctx.arc(this.width / 2 - 15, this.height / 2, 8, 0.5 * Math.PI, 1.5 * Math.PI);
                    ctx.stroke();
                    
                    // å³é’³å­
                    ctx.beginPath();
                    ctx.arc(this.width / 2 - 15, this.height / 2, 8, 1.5 * Math.PI, 0.5 * Math.PI);
                    ctx.stroke();
                    
                    // è…¿
                    ctx.strokeStyle = '#e76f51';
                    ctx.lineWidth = 2;
                    
                    // ç»˜åˆ¶å¤šæ¡è…¿ï¼Œå¸¦æœ‰åŠ¨ç”»
                    for (let i = 0; i < 3; i++) {
                        const legY = this.height / 2 + (i - 1) * 5;
                        const legPhase = Math.sin(this.legPhase + i * Math.PI / 3) * 5;
                        
                        // å·¦è…¿
                        ctx.beginPath();
                        ctx.moveTo(5, legY);
                        ctx.lineTo(-5, legY + legPhase);
                        ctx.lineTo(-12, legY);
                        ctx.stroke();
                        
                        // å³è…¿
                        ctx.beginPath();
                        ctx.moveTo(this.width - 5, legY);
                        ctx.lineTo(this.width + 5, legY - legPhase);
                        ctx.lineTo(this.width + 12, legY);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            };
            
            gameObjects.push(crab);
        }
        
        // åˆ›å»ºå²©çŸ³
        function createRock(x, groundY, word, isEnglishDisplay) {
            const rockHeight = 70 + Math.random() * 50;
            
            const rock = {
                x: x,
                y: groundY - rockHeight,
                width: 100,
                height: rockHeight,
                type: 'obstacle',
                obstacleType: 'rock',
                word: word,
                isEnglishDisplay: isEnglishDisplay,
                visited: false,
                translationVisible: false,
                color: '#666',
                draw: function(ctx) {
                    ctx.fillStyle = this.color;
                    
                    // ç»˜åˆ¶ä¸è§„åˆ™å²©çŸ³å½¢çŠ¶
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + this.height);
                    ctx.lineTo(this.x, this.y + this.height * 0.7);
                    ctx.lineTo(this.x + this.width * 0.3, this.y + this.height * 0.5);
                    ctx.lineTo(this.x + this.width * 0.5, this.y);
                    ctx.lineTo(this.x + this.width * 0.8, this.y + this.height * 0.3);
                    ctx.lineTo(this.x + this.width, this.y + this.height * 0.8);
                    ctx.lineTo(this.x + this.width, this.y + this.height);
                    ctx.closePath();
                    ctx.fill();
                    
                    // å•è¯æ–‡æœ¬å°†ç”±drawWordTextså‡½æ•°ç»˜åˆ¶ï¼Œä¸å†åœ¨æ­¤å¤„ç»˜åˆ¶
                }
            };
            
            gameObjects.push(rock);
            platforms.push(rock);
        }
        
        // åˆ›å»ºå°é˜¶
        function createStairs(x, groundY, word, isEnglishDisplay) {
            const stairCount = 3 + Math.floor(Math.random() * 3); // 3-5ä¸ªå°é˜¶
            const stairWidth = 70;
            const stairHeight = 30;
            
            for (let i = 0; i < stairCount; i++) {
                const stair = {
                    x: x + i * stairWidth * 0.8,
                    y: groundY - (i + 1) * stairHeight,
                    width: stairWidth,
                    height: stairHeight,
                    type: 'platform',
                    obstacleType: 'stair',
                    word: i === Math.floor(stairCount / 2) ? word : null,
                    isEnglishDisplay: isEnglishDisplay,
                    visited: false,
                    translationVisible: false,
                    color: '#a38560',
                    draw: function(ctx) {
                        ctx.fillStyle = this.color;
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                        
                        // ç»˜åˆ¶çº¹ç†çº¿æ¡
                        ctx.strokeStyle = '#7d6445';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + this.height / 3);
                        ctx.lineTo(this.x + this.width, this.y + this.height / 3);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + this.height * 2/3);
                        ctx.lineTo(this.x + this.width, this.y + this.height * 2/3);
                        ctx.stroke();
                        
                        // å•è¯æ–‡æœ¬å°†ç”±drawWordTextså‡½æ•°ç»˜åˆ¶ï¼Œä¸å†åœ¨æ­¤å¤„ç»˜åˆ¶
                    }
                };
                
                gameObjects.push(stair);
                platforms.push(stair);
            }
        }
        
        // åˆ›å»ºæ¤ç‰©
        function createPlant(x, groundY, word, isEnglishDisplay) {
            const plantHeight = 100 + Math.random() * 50;
            
            const plant = {
                x: x,
                y: groundY - plantHeight,
                width: 60,
                height: plantHeight,
                type: 'obstacle',
                obstacleType: 'plant',
                word: word,
                isEnglishDisplay: isEnglishDisplay,
                visited: false,
                translationVisible: false,
                color: getSeasonColor('trees'),
                draw: function(ctx) {
                    // ç»˜åˆ¶æ¤ç‰©èŒå¹²
                    ctx.fillStyle = '#7d6445';
                    ctx.fillRect(this.x + this.width/2 - 5, this.y + 30, 10, this.height - 30);
                    
                    // ç»˜åˆ¶å¶å­
                    ctx.fillStyle = this.color;
                    
                    // å·¦ä¾§å¶å­
                    ctx.beginPath();
                    ctx.ellipse(this.x + 15, this.y + 50, 15, 30, Math.PI/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // å³ä¾§å¶å­
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width - 15, this.y + 70, 15, 30, -Math.PI/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // é¡¶éƒ¨
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width/2, this.y + 20, 30, 20, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // å•è¯æ–‡æœ¬å°†ç”±drawWordTextså‡½æ•°ç»˜åˆ¶ï¼Œä¸å†åœ¨æ­¤å¤„ç»˜åˆ¶
                }
            };
            
            gameObjects.push(plant);
        }
        
        // ç¯å¢ƒå˜é‡
        const environment = {
            time: 0, // 0-1æ—¥å¤œå¾ªç¯
            weather: 'clear', // clear, rain, fog
            weatherTimer: 0,
            weatherDuration: 0,
            nextWeatherChange: Math.random() * 120000 + 120000, // 2-4åˆ†é’Ÿåæ”¹å˜å¤©æ°”
            raindrops: [],
            fogOpacity: 0
        };
        
        // åˆå§‹åŒ–ç¯å¢ƒ
        function initEnvironment() {
            environment.time = 0.3; // ä»æ—©æ™¨å¼€å§‹
            environment.weather = 'clear';
            environment.weatherTimer = 0;
            environment.weatherDuration = 0;
            environment.nextWeatherChange = Math.random() * 120000 + 120000;
            environment.raindrops = [];
            environment.fogOpacity = 0;
        }
        
        // æ›´æ–°ç¯å¢ƒ
        function updateEnvironment(deltaTime) {
            // æ›´æ–°æ—¶é—´ï¼ˆæ—¥å¤œå¾ªç¯ï¼‰ï¼Œä¸€ä¸ªå®Œæ•´å‘¨æœŸçº¦15åˆ†é’Ÿ
            environment.time = (environment.time + deltaTime * 0.000003) % 1;
            
            // æ›´æ–°å¤©æ°”è®¡æ—¶å™¨
            environment.weatherTimer += deltaTime;
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦æ”¹å˜å¤©æ°”
            if (environment.weatherTimer > environment.nextWeatherChange) {
                changeWeather();
            }
            
            // æ›´æ–°å­£èŠ‚è¿‡æ¸¡
            if (seasonChangeStarted) {
                seasonTransition += deltaTime * 0.0001; // æ…¢æ…¢è¿‡æ¸¡
                if (seasonTransition >= 1) {
                    seasonTransition = 0;
                    currentSeason = nextSeason;
                    seasonChangeStarted = false;
                }
            }
            
            // æ ¹æ®å½“å‰å¤©æ°”æ›´æ–°ç¯å¢ƒæ•ˆæœ
            switch (environment.weather) {
                case 'rain':
                    updateRain();
                    break;
                    
                case 'fog':
                    updateFog(deltaTime);
                    break;
            }
            
            // æ›´æ–°ç‰¹æ®Šå¤©æ°”æ•ˆæœ
            updateSpecialWeatherEffects(deltaTime);
            
            // æ›´æ–°è·³æ¿ - è·³æ¿ä¸å†æ¶ˆå¤±
            for (let i = 0; i < jumpboards.length/2; i++) {
                if (jumpboards[i].update) {
                    jumpboards[i].update(deltaTime);
                }
                
                if (jumpboards[i].checkInteraction) {
                    jumpboards[i].checkInteraction(player);
                }
            }
            
            // æ›´æ–°é¸Ÿç±»
            for (let i = birds.length - 1; i >= 0; i--) {
                if (birds[i].update) {
                    const isActive = birds[i].update(deltaTime);
                    if (isActive === false) {
                        birds.splice(i, 1);
                    }
                }
            }
            
            // æ›´æ–°é¸­å­
            for (let i = 0; i < ducks.length; i++) {
                if (ducks[i].update) {
                    ducks[i].update(deltaTime);
                }
            }
            // æ§åˆ¶é¸Ÿçš„éšæœºç”Ÿæˆ
if (birds.length < 3 && Math.random() < 0.3) { // æ¯å¸§æœ‰0.2%çš„æ¦‚ç‡ç”Ÿæˆæ–°é¸Ÿï¼Œæœ€å¤šåŒæ—¶å­˜åœ¨3åª
    createBird(camera.x - 300, camera.y + Math.random() * (gameHeight * 0.6));
}
        }
        
        // æ›´æ–°ç‰¹æ®Šå¤©æ°”æ•ˆæœ
        function updateSpecialWeatherEffects(deltaTime) {
            // æ›´æ–°é—ªç”µæ•ˆæœ
            if (weatherEffects.lightning.active) {
                weatherEffects.lightning.lastFlash += deltaTime;
                
                // æ£€æŸ¥æ˜¯å¦è¯¥é—ªçƒé—ªç”µ
                if (weatherEffects.lightning.lastFlash > weatherEffects.lightning.nextFlash) {
                    // éšæœºç”Ÿæˆä¸‹ä¸€æ¬¡é—ªç”µæ—¶é—´
                    weatherEffects.lightning.nextFlash = Math.random() * 10000 + 5000; // 5-15ç§’
                    weatherEffects.lightning.lastFlash = 0;
                    
                    // é—ªç”µåŠ¨ç”»
                    flashLightning();
                }
                
                // é—ªç”µäº®åº¦è¡°å‡
                if (weatherEffects.lightning.opacity > 0) {
                    weatherEffects.lightning.opacity -= deltaTime * 0.002;
                    if (weatherEffects.lightning.opacity < 0) {
                        weatherEffects.lightning.opacity = 0;
                    }
                }
            }
            
            // æ›´æ–°æ²™å°˜æš´æ•ˆæœ
            if (weatherEffects.sandstorm.active) {
                // æ›´æ–°æ²™å°˜å¼ºåº¦
                if (weatherEffects.sandstorm.intensity < 1) {
                    weatherEffects.sandstorm.intensity += deltaTime * 0.0005;
                    if (weatherEffects.sandstorm.intensity > 1) {
                        weatherEffects.sandstorm.intensity = 1;
                    }
                }
                
                // æ›´æ–°æ²™ç²’ä½ç½®
                for (let i = weatherEffects.sandstorm.particles.length - 1; i >= 0; i--) {
                    const particle = weatherEffects.sandstorm.particles[i];
                    
                    // å‘å·¦ç§»åŠ¨æ²™ç²’
                    particle.x -= particle.speed;
                    
                    // å¦‚æœæ²™ç²’ç¦»å¼€å±å¹•ï¼Œé‡æ–°æ”¾ç½®åˆ°å³ä¾§
                    if (particle.x < camera.x - 50) {
                        particle.x = camera.x + gameWidth + 50;
                        particle.y = camera.y + Math.random() * gameHeight;
                    }
                }
                
                // æ·»åŠ æ–°æ²™ç²’
                if (Math.random() < 0.3 && weatherEffects.sandstorm.particles.length < 300) {
                    addSandParticle();
                }
            }
            
            // æ›´æ–°å½©è™¹æ•ˆæœ
            if (weatherEffects.rainbow.active) {
                // æ¸å˜æ˜¾ç¤º/éšè—å½©è™¹
                if (weatherEffects.rainbow.opacity < 1) {
                    weatherEffects.rainbow.opacity += deltaTime * 0.0005;
                    if (weatherEffects.rainbow.opacity > 1) {
                        weatherEffects.rainbow.opacity = 1;
                    }
                    document.getElementById('rainbow').style.opacity = weatherEffects.rainbow.opacity.toString();
                }
            }
        }
        
        // é—ªç”µé—ªçƒæ•ˆæœ
        function flashLightning() {
            // éšæœºé—ªç”µäº®åº¦
            weatherEffects.lightning.opacity = 0.7 + Math.random() * 0.3;
            
            // å¯ä»¥æ·»åŠ éœ‡åŠ¨ç‰¹æ•ˆæˆ–å£°éŸ³æ•ˆæœ
            if (Math.random() > 0.5) {
                // æ·»åŠ éšæœºéœ‡åŠ¨æ•ˆæœ
                const shakeAmount = 5 + Math.random() * 5;
                shakeScreen(shakeAmount);
            }
        }
        
        // å±å¹•éœ‡åŠ¨æ•ˆæœ
        function shakeScreen(amount) {
            const gameContainer = document.getElementById('gameContainer');
            
            // éšæœºæ–¹å‘éœ‡åŠ¨
            const shakeX = (Math.random() - 0.5) * amount;
            const shakeY = (Math.random() - 0.5) * amount;
            
            gameContainer.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
            
            // éœ‡åŠ¨ç»“æŸåæ¢å¤
            setTimeout(() => {
                gameContainer.style.transform = '';
            }, 100);
        }
        
        // æ”¹å˜å¤©æ°”
        function changeWeather() {
            const weathers = ['clear', 'rain', 'fog'];
            let newWeather;
            
            do {
                newWeather = weathers[Math.floor(Math.random() * weathers.length)];
            } while (newWeather === environment.weather);
            
            environment.weather = newWeather;
            environment.weatherTimer = 0;
            environment.weatherDuration = 0;
            environment.nextWeatherChange = Math.random() * 120000 + 120000; // 2-4åˆ†é’Ÿ
            
            // åˆå§‹åŒ–æ–°å¤©æ°”æ•ˆæœ
            if (environment.weather === 'rain') {
                environment.raindrops = [];
                for (let i = 0; i < 100; i++) {
                    addRaindrop();
                }
            } else if (environment.weather === 'fog') {
                environment.fogOpacity = 0;
            }
        }
        
        // æ›´æ–°é›¨æ•ˆæœ
        function updateRain() {
            // æ›´æ–°ç°æœ‰é›¨æ»´
            for (let i = environment.raindrops.length - 1; i >= 0; i--) {
                const drop = environment.raindrops[i];
                drop.y += drop.speed;
                drop.x += drop.speedX;
                
                // å¦‚æœé›¨æ»´ç¦»å¼€å±å¹•ï¼Œé‡ç½®ä½ç½®
                if (drop.y > camera.y + gameHeight) {
                    drop.y = camera.y - 10;
                    drop.x = camera.x + Math.random() * gameWidth;
                }
            }
            
            // éšæœºæ·»åŠ æ–°é›¨æ»´
            if (Math.random() < 0.3 && environment.raindrops.length < 300) {
                addRaindrop();
            }
        }
        
        // æ·»åŠ é›¨æ»´
        function addRaindrop() {
            environment.raindrops.push({
                x: camera.x + Math.random() * gameWidth,
                y: camera.y - 10,
                speed: 10 + Math.random() * 5,
                speedX: -1 - Math.random(), // é£çš„æ•ˆæœ
                length: 10 + Math.random() * 15
            });
        }
        
        // æ›´æ–°é›¾æ•ˆæœ
        function updateFog(deltaTime) {
            // é€æ¸å¢åŠ é›¾çš„ä¸é€æ˜åº¦ï¼Œç›´åˆ°è¾¾åˆ°æœ€å¤§å€¼
            if (environment.weatherDuration < 5000) {
                environment.weatherDuration += deltaTime;
                environment.fogOpacity = Math.min(0.5, environment.weatherDuration / 10000);
            }
        }
        
        // ç»˜åˆ¶ç¯å¢ƒæ•ˆæœ - é™æ€èƒŒæ™¯
        function drawGameBackground(ctx) {
            // ç»˜åˆ¶å›ºå®šèƒŒæ™¯è‰² - ä½¿ç”¨å½“å‰å­£èŠ‚çš„é¢œè‰²
            const gradient = ctx.createLinearGradient(0, 0, 0, gameHeight);
            gradient.addColorStop(0, '#1e3a8a'); // æ·±è“è‰²é¡¶éƒ¨
            gradient.addColorStop(1, '#3b82f6'); // æµ…è“è‰²åº•éƒ¨
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            
            // ç»˜åˆ¶ä¸€äº›äº‘æœµè£…é¥°
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            
            for (let i = 0; i < 5; i++) {
                const cloudX = i * 200 + (gameTime * 0.01) % (gameWidth * 2) - gameWidth;
                const cloudY = 50 + Math.sin(i * 0.7) * 30;
                
                drawCloud(ctx, cloudX, cloudY);
            }
        }
        
        // ç»˜åˆ¶åŠ¨æ€ç¯å¢ƒæ•ˆæœ - ç”¨äºæ¸¸æˆä¸–ç•Œ
        function drawEnvironment(ctx) {
            // æ ¹æ®æ—¶é—´å’Œå­£èŠ‚ç»˜åˆ¶å¤©ç©ºé¢œè‰²
            let skyColor, horizonColor;
            
            // è·å–å½“å‰å­£èŠ‚çš„å¤©ç©ºé¢œè‰²
            const seasonSkyTop = getSeasonColor('skyTop');
            const seasonSkyBottom = getSeasonColor('skyBottom');
            
            if (environment.time < 0.25) { // æ—©æ™¨
                const t = environment.time / 0.25;
                skyColor = interpolateColor('#0c2461', seasonSkyTop, t);
                horizonColor = interpolateColor('#eb2f06', seasonSkyBottom, t);
            } else if (environment.time < 0.75) { // ç™½å¤©
                const t = (environment.time - 0.25) / 0.5;
                skyColor = interpolateColor(seasonSkyTop, '#0c2461', t);
                horizonColor = interpolateColor(seasonSkyBottom, '#eb2f06', t);
            } else { // æ™šä¸Š
                const t = (environment.time - 0.75) / 0.25;
                skyColor = interpolateColor('#0c2461', '#0c2461', t);
                horizonColor = interpolateColor('#eb2f06', '#0c2461', t);
            }
            
            // è¿™é‡Œåªç»˜åˆ¶æ¸¸æˆä¸–ç•Œå†…çš„å¤©ç©ºæ•ˆæœ
            const gradient = ctx.createLinearGradient(0, 0, 0, gameHeight);
            gradient.addColorStop(0, skyColor);
            gradient.addColorStop(1, horizonColor);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(camera.x, camera.y, gameWidth, gameHeight);
            
          // ç»˜åˆ¶å¤ªé˜³æˆ–æœˆäº®
          if (environment.time < 0.5) {
                // å¤ªé˜³
                const sunProgress = environment.time / 0.5;
                const sunX = camera.x + gameWidth * (0.1 + sunProgress * 0.8);
                const sunY = camera.y + gameHeight * (0.8 - sunProgress * 0.6);
                
                const sunGlow = ctx.createRadialGradient(
                    sunX, sunY, 0,
                    sunX, sunY, 60
                );
                sunGlow.addColorStop(0, 'rgba(255, 255, 190, 1)');
                sunGlow.addColorStop(0.3, 'rgba(255, 200, 100, 0.8)');
                sunGlow.addColorStop(1, 'rgba(255, 200, 100, 0)');
                
                ctx.fillStyle = sunGlow;
                ctx.fillRect(sunX - 60, sunY - 60, 120, 120);
                
                ctx.fillStyle = '#fffcba';
                ctx.beginPath();
                ctx.arc(sunX, sunY, 30, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // æœˆäº®
                const moonProgress = (environment.time - 0.5) / 0.5;
                const moonX = camera.x + gameWidth * (0.9 - moonProgress * 0.8);
                const moonY = camera.y + gameHeight * (0.2 + moonProgress * 0.6);
                
                // æœˆå…‰å…‰æ™•
                const moonGlow = ctx.createRadialGradient(
                    moonX, moonY, 0,
                    moonX, moonY, 50
                );
                moonGlow.addColorStop(0, 'rgba(230, 230, 255, 0.7)');
                moonGlow.addColorStop(1, 'rgba(230, 230, 255, 0)');
                
                ctx.fillStyle = moonGlow;
                ctx.fillRect(moonX - 50, moonY - 50, 100, 100);
                
                // æœˆäº®
                ctx.fillStyle = '#e6e6ff';
                ctx.beginPath();
                ctx.arc(moonX, moonY, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // æœˆäº®è¡¨é¢çš„é™¨çŸ³å‘
                ctx.fillStyle = 'rgba(200, 200, 230, 0.8)';
                ctx.beginPath();
                ctx.arc(moonX - 8, moonY - 5, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(moonX + 5, moonY + 8, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(moonX + 7, moonY - 7, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ç»˜åˆ¶æ˜Ÿæ˜Ÿï¼ˆä»…åœ¨æ™šä¸Šï¼‰
            if (environment.time > 0.7 || environment.time < 0.2) {
                ctx.fillStyle = 'white';
                
                for (let i = 0; i < 100; i++) {
                    const starX = (i * 173) % gameWidth + camera.x;
                    const starY = (i * 121) % gameHeight * 0.8 + camera.y;
                    
                    // æ˜Ÿæ˜Ÿé—ªçƒæ•ˆæœ
                    const twinkle = 0.5 + Math.sin(gameTime * 0.001 + i) * 0.5;
                    const size = 1 + Math.sin(gameTime * 0.0003 + i * 0.7) * 0.5;
                    
                    ctx.globalAlpha = twinkle;
                    ctx.fillRect(starX, starY, size, size);
                }
                
                ctx.globalAlpha = 1;
            }
            
            // æ ¹æ®å¤©æ°”ç»˜åˆ¶é¢å¤–æ•ˆæœ
            switch (environment.weather) {
                case 'rain':
                    drawRain(ctx);
                    break;
                    
                case 'fog':
                    drawFog(ctx);
                    break;
            }
            
            // ç»˜åˆ¶æ”¹è¿›çš„å±±è„‰ - ä¸å†åªæ˜¯ä¸‰è§’å½¢
            drawMountains(ctx);
            
            // ç»˜åˆ¶ç‰¹æ®Šå¤©æ°”æ•ˆæœ
            drawSpecialWeatherEffects(ctx);
        }
        
        // ç»˜åˆ¶ç‰¹æ®Šå¤©æ°”æ•ˆæœ
        function drawSpecialWeatherEffects(ctx) {
            // ç»˜åˆ¶é—ªç”µ
            if (weatherEffects.lightning.active && weatherEffects.lightning.opacity > 0) {
                // ç»˜åˆ¶é—ªç”µè¦†ç›–æ•´ä¸ªå±å¹•çš„ç™½è‰²é—ªå…‰
                ctx.fillStyle = `rgba(255, 255, 255, ${weatherEffects.lightning.opacity})`;
                ctx.fillRect(camera.x, camera.y, gameWidth, gameHeight);
                
                // éšæœºç»˜åˆ¶å‡ é“é—ªç”µ
                if (weatherEffects.lightning.opacity > 0.5) {
                    drawLightningBolt(ctx);
                }
            }
            
            // ç»˜åˆ¶æ²™å°˜æš´
            if (weatherEffects.sandstorm.active) {
                // ç»˜åˆ¶æ²™å°˜æš´ç²’å­
                for (const particle of weatherEffects.sandstorm.particles) {
                    ctx.fillStyle = particle.color;
                    ctx.globalAlpha = particle.opacity * weatherEffects.sandstorm.intensity;
                    ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                }
                
                // ç»˜åˆ¶æ²™å°˜æš´è¦†ç›–å±‚
                ctx.globalAlpha = 0.2 * weatherEffects.sandstorm.intensity;
                ctx.fillStyle = '#d2b48c'; // æ²™è‰²
                ctx.fillRect(camera.x, camera.y, gameWidth, gameHeight);
                
                ctx.globalAlpha = 1;
            }
            
            // å½©è™¹æ•ˆæœåœ¨HTMLä¸­é€šè¿‡SVGç»˜åˆ¶
        }
        
        // ç»˜åˆ¶é—ªç”µ
        function drawLightningBolt(ctx) {
            // åœ¨å±å¹•ä¸Šéšæœºä½ç½®ç»˜åˆ¶é—ªç”µ
            const startX = camera.x + Math.random() * gameWidth;
            const startY = camera.y;
            let endY = camera.y + gameHeight * 0.7 + Math.random() * (gameHeight * 0.3);
            
            // é—ªç”µè·¯å¾„
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            
            let currentX = startX;
            let currentY = startY;
            
            // åˆ›å»ºé”¯é½¿çŠ¶é—ªç”µ
            while (currentY < endY) {
                // ä¸‹ä¸€ä¸ªç‚¹çš„åç§»
                const nextX = currentX + (Math.random() - 0.5) * 100;
                const nextY = currentY + Math.random() * 50 + 20;
                
                ctx.lineTo(nextX, nextY);
                
                currentX = nextX;
                currentY = nextY;
            }
            
            ctx.stroke();
            
            // ç»˜åˆ¶é—ªç”µçš„å‘å…‰æ•ˆæœ
            const gradient = ctx.createLinearGradient(startX, startY, currentX, currentY);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(100, 149, 237, 0.2)');
            
            ctx.lineWidth = 8;
            ctx.strokeStyle = gradient;
            ctx.stroke();
        }
        
        // ç»˜åˆ¶æ”¹è¿›çš„å±±è„‰
        // ä¿®æ”¹drawMountainså‡½æ•°
// ä¿®æ”¹drawMountainså‡½æ•°ä½¿ç”¨è¿™äº›å›ºå®šä½ç½®
// ä¿®æ”¹generateBackgroundå‡½æ•°
function generateBackground() {
    // æ¸…ç©ºèƒŒæ™¯æ•°ç»„
    backgrounds.length = 0;
    mountainPositions.length = 0;
    hillPositions.length = 0;
    
    // åˆå§‹åŒ–ç”Ÿæˆå˜é‡
    farthestMountainGenerated = -3000;
    farthestHillGenerated = -2000;
    
    // åªç”Ÿæˆåˆå§‹çš„ä¸€æ®µå±±è„‰å’Œå°å±±ä¸˜
    generateInitialMountains();
    
    // æ·»åŠ èƒŒæ™¯ç»˜åˆ¶å‡½æ•°
    backgrounds.push({
        draw: function(ctx) {
            drawEnvironment(ctx);
        }
    });
}

// ä¿®æ”¹drawMountainså‡½æ•°ï¼Œä¼˜åŒ–ç»˜åˆ¶é€»è¾‘
function drawMountains(ctx) {
    ctx.fillStyle = getSeasonColor('ground');
    
    // ç»˜åˆ¶è¿œæ™¯å±±è„‰ - æ‰€æœ‰å±±è„‰æ•°ç»„ä¸­çš„å±±
    for (const mountain of mountainPositions) {
        // ä½¿ç”¨è¾ƒå¤§çš„è§†è·èŒƒå›´ï¼Œä½†è§†å·®æ•ˆæœæ›´å°ä»¥é¿å…æŠ–åŠ¨
        if (mountain.x > camera.x - 2000 && mountain.x < camera.x + gameWidth + 2000) {
            // ä½¿ç”¨è¾ƒå°çš„è§†å·®ç³»æ•°ï¼Œè®©å±±è„‰ç§»åŠ¨æ›´å¹³æ»‘
            const mountainX = mountain.x - camera.x * 0.3; // è§†å·®æ•ˆæœ
            const baseHeight = mountain.height;
            const seed = mountain.seed;
            
            // ç»˜åˆ¶å±±è„‰å½¢çŠ¶
            ctx.beginPath();
            ctx.moveTo(mountainX - 150, gameHeight - 50);
            
            const leftHeight = baseHeight * (0.6 + seed * 0.3);
            const topHeight = baseHeight;
            const rightHeight = baseHeight * (0.5 + (1-seed) * 0.4);
            
            ctx.bezierCurveTo(
                mountainX - 50, gameHeight - 50 - leftHeight * 0.8,
                mountainX + 30, gameHeight - 50 - leftHeight,
                mountainX + 100, gameHeight - 50 - topHeight
            );
            
            ctx.lineTo(mountainX + 100, gameHeight - 50 - topHeight);
            
            ctx.bezierCurveTo(
                mountainX + 170, gameHeight - 50 - rightHeight,
                mountainX + 250, gameHeight - 50 - rightHeight * 0.5,
                mountainX + 350, gameHeight - 50
            );
            
            ctx.closePath();
            ctx.fill();
            
            // æ·»åŠ å±±ä¸Šçš„é›ªï¼ˆå†¬å­£ï¼‰
            if (currentSeason === 'winter' || 
                (seasonChangeStarted && nextSeason === 'winter' && seasonTransition > 0.5)) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                
                ctx.beginPath();
                ctx.moveTo(mountainX + 40, gameHeight - 50 - topHeight * 0.7);
                ctx.bezierCurveTo(
                    mountainX + 70, gameHeight - 50 - topHeight * 0.9,
                    mountainX + 130, gameHeight - 50 - topHeight * 0.9,
                    mountainX + 160, gameHeight - 50 - topHeight * 0.7
                );
                ctx.lineTo(mountainX + 100, gameHeight - 50 - topHeight);
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = getSeasonColor('ground');
            }
        }
    }
    
    // ç»˜åˆ¶è¿‘æ™¯å°å±±ä¸˜
    for (const hill of hillPositions) {
        if (hill.x > camera.x - 1000 && hill.x < camera.x + gameWidth + 1000) {
            const hillX = hill.x - camera.x * 0.6; // è§†å·®æ•ˆæœ
            const hillHeight = hill.height;
            const seed = hill.seed;
            
            ctx.fillStyle = adjustBrightness(getSeasonColor('ground'), 1.1);
            
            ctx.beginPath();
            ctx.moveTo(hillX - 80, gameHeight - 50);
            
            const leftHeight = hillHeight * (0.7 + seed * 0.3);
            const topHeight = hillHeight;
            const rightHeight = hillHeight * (0.6 + (1-seed) * 0.4);
            
            ctx.bezierCurveTo(
                hillX - 20, gameHeight - 50 - leftHeight * 0.8,
                hillX + 30, gameHeight - 50 - topHeight,
                hillX + 80, gameHeight - 50 - rightHeight
            );
            
            ctx.bezierCurveTo(
                hillX + 130, gameHeight - 50 - rightHeight * 0.7,
                hillX + 180, gameHeight - 50 - rightHeight * 0.3,
                hillX + 230, gameHeight - 50
            );
            
            ctx.closePath();
            ctx.fill();
        }
    }
}
        // è°ƒæ•´é¢œè‰²äº®åº¦
        function adjustBrightness(color, factor) {
            if (color.startsWith('#')) {
                const r = parseInt(color.substr(1, 2), 16);
                const g = parseInt(color.substr(3, 2), 16);
                const b = parseInt(color.substr(5, 2), 16);
                
                const newR = Math.min(255, Math.round(r * factor));
                const newG = Math.min(255, Math.round(g * factor));
                const newB = Math.min(255, Math.round(b * factor));
                
                return `rgb(${newR}, ${newG}, ${newB})`;
            } else if (color.startsWith('rgb')) {
                const match = color.match(/\d+/g);
                if (match && match.length >= 3) {
                    const r = parseInt(match[0]);
                    const g = parseInt(match[1]);
                    const b = parseInt(match[2]);
                    
                    const newR = Math.min(255, Math.round(r * factor));
                    const newG = Math.min(255, Math.round(g * factor));
                    const newB = Math.min(255, Math.round(b * factor));
                    
                    return `rgb(${newR}, ${newG}, ${newB})`;
                }
            }
            return color;
        }
        
        // ç»˜åˆ¶äº‘æœµ
        function drawCloud(ctx, x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 30, 0, Math.PI * 2);
            ctx.arc(x + 25, y - 10, 25, 0, Math.PI * 2);
            ctx.arc(x + 45, y, 20, 0, Math.PI * 2);
            ctx.arc(x + 25, y + 10, 15, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        }
        
        // é¢œè‰²æ’å€¼å‡½æ•°
        function interpolateColor(color1, color2, t) {
            // è§£æé¢œè‰²
            const parseColor = (color) => {
                if (color.startsWith('#')) {
                    const r = parseInt(color.substr(1, 2), 16);
                    const g = parseInt(color.substr(3, 2), 16);
                    const b = parseInt(color.substr(5, 2), 16);
                    return [r, g, b];
                } else if (color.startsWith('rgb')) {
                    const match = color.match(/\d+/g);
                    if (match && match.length >= 3) {
                        return [parseInt(match[0]), parseInt(match[1]), parseInt(match[2])];
                    }
                }
                return [0, 0, 0];
            };
            
            const [r1, g1, b1] = parseColor(color1);
            const [r2, g2, b2] = parseColor(color2);
            
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // ç»˜åˆ¶é›¨
        function drawRain(ctx) {
            ctx.strokeStyle = 'rgba(200, 220, 255, 0.6)';
            ctx.lineWidth = 1;
            
            for (const drop of environment.raindrops) {
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x + drop.speedX * 2, drop.y + drop.length);
                ctx.stroke();
            }
            
            // é›¨å¤©çš„é˜´å½±æ•ˆæœ
            ctx.fillStyle = 'rgba(0, 10, 50, 0.1)';
            ctx.fillRect(camera.x, camera.y, gameWidth, gameHeight);
            
            // å†¬å­£æ—¶é›¨å˜æˆé›ª
            if (currentSeason === 'winter' || 
                (seasonChangeStarted && nextSeason === 'winter' && seasonTransition > 0.5)) {
                drawSnow(ctx);
            }
        }
        
        // ç»˜åˆ¶é›ªï¼ˆå†¬å­£ç‰¹æ•ˆï¼‰
        function drawSnow(ctx) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            
            for (const drop of environment.raindrops) {
                // å°†é›¨æ»´ç»˜åˆ¶ä¸ºé›ªèŠ±
                const size = 2 + Math.random() * 3;
                
                ctx.beginPath();
                ctx.arc(drop.x, drop.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // ä¸€äº›é›ªèŠ±æ·»åŠ ç®€å•çš„ç»“æ™¶å›¾æ¡ˆ
                if (Math.random() > 0.7) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 1;
                    
                    // ç»˜åˆ¶é›ªèŠ±ç»“æ™¶çº¿
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI;
                        ctx.beginPath();
                        ctx.moveTo(drop.x, drop.y);
                        ctx.lineTo(
                            drop.x + Math.cos(angle) * size * 2,
                            drop.y + Math.sin(angle) * size * 2
                        );
                        ctx.stroke();
                    }
                }
            }
        }
        
        // ç»˜åˆ¶é›¾
        function drawFog(ctx) {
            ctx.fillStyle = `rgba(200, 220, 255, ${environment.fogOpacity})`;
            ctx.fillRect(camera.x, camera.y, gameWidth, gameHeight);
            
            // ç»˜åˆ¶ä¸€äº›éšæœºçš„é›¾æ°”æµåŠ¨
            for (let i = 0; i < 10; i++) {
                const fogX = (camera.x + (i * 500 + gameTime * 0.05) % (gameWidth * 2)) - gameWidth * 0.5;
                const fogY = camera.y + (Math.sin(i * 0.7) * 0.3 + 0.5) * gameHeight;
                
                const fogGradient = ctx.createRadialGradient(
                    fogX, fogY, 0,
                    fogX, fogY, 300
                );
                fogGradient.addColorStop(0, `rgba(255, 255, 255, ${environment.fogOpacity * 0.7})`);
                fogGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = fogGradient;
                ctx.fillRect(fogX - 300, fogY - 300, 600, 600);
            }
        }
        // æ·»åŠ è¿™ä¸ªå…¨å±€å˜é‡æ•°ç»„ç”¨äºå­˜å‚¨å±±è„‰ä½ç½®
const mountainPositions = [];
const hillPositions = [];
let farthestMountainGenerated = -3000; // å·²ç”Ÿæˆçš„æœ€è¿œå±±è„‰ä½ç½®
let farthestHillGenerated = -2000;     // å·²ç”Ÿæˆçš„æœ€è¿œå°å±±ä¸˜ä½ç½®
        // ç”ŸæˆèƒŒæ™¯ - ç°åœ¨ç”±drawGameBackgroundå’ŒdrawEnvironmentåˆ†å¼€å¤„ç†
        // ä¿®æ”¹generateBackgroundå‡½æ•°
        function generateBackground() {
    // æ¸…ç©ºèƒŒæ™¯æ•°ç»„
    backgrounds.length = 0;
    mountainPositions.length = 0;
    hillPositions.length = 0;
    
    // åˆå§‹åŒ–ç”Ÿæˆå˜é‡
    farthestMountainGenerated = -3000;
    farthestHillGenerated = -2000;
    
    // åªç”Ÿæˆåˆå§‹çš„ä¸€æ®µå±±è„‰å’Œå°å±±ä¸˜
    generateInitialMountains();
    
    // æ·»åŠ èƒŒæ™¯ç»˜åˆ¶å‡½æ•°
    backgrounds.push({
        draw: function(ctx) {
            drawEnvironment(ctx);
        }
    });
}
// æ–°å¢å‡½æ•°ï¼šç”Ÿæˆåˆå§‹çš„å±±è„‰å’Œå°å±±ä¸˜
function generateInitialMountains() {
    // ç”Ÿæˆåˆå§‹å±å¹•å’Œå‰æ–¹è¾ƒè¿œè·ç¦»çš„å±±è„‰
    const initialDistance = gameWidth * 10; // ç”Ÿæˆåˆå§‹å±å¹•å®½åº¦çš„10å€
    
    // ç”Ÿæˆè¿œå¤„çš„å±±è„‰
    let mountainX = -10000; // ä»è¿œå¤„å±å¹•å¤–å¼€å§‹
    while (mountainX < initialDistance) {
        if (Math.random() > 0.4) { // 60%å‡ ç‡ç”Ÿæˆå±±è„‰
            mountainPositions.push({
                x: mountainX,
                height: 60 + Math.random() * 60,
                seed: Math.random() // ä¿å­˜éšæœºç§å­ç”¨äºå½¢çŠ¶
            });
        }
        mountainX += 600 + Math.random() * 800;
    }
    
    farthestMountainGenerated = mountainX;
    
    // ç”Ÿæˆå°å±±ä¸˜
    let hillX = -20000;
    while (hillX < initialDistance) {
        if (Math.random() > 0.3) { // 70%å‡ ç‡ç”Ÿæˆå°å±±ä¸˜
            hillPositions.push({
                x: hillX,
                height: 30 + Math.random() * 25,
                seed: Math.random()
            });
        }
        hillX += 300 + Math.random() * 400;
    }
    
    farthestHillGenerated = hillX;
}

      // æ–°å¢å‡½æ•°ï¼šæ ¹æ®ç©å®¶ä½ç½®æ£€æŸ¥å¹¶ç”Ÿæˆå±±è„‰
function checkAndGenerateMountains() {
    // è®¡ç®—ç©å®¶è·ç¦»å³è¾¹å±å¹•è¾¹ç¼˜çš„è·ç¦»
    const playerDistanceToRightEdge = (camera.x + gameWidth) - (player.x + player.width);
    
    // å¦‚æœç©å®¶è·ç¦»å³è¾¹ç¼˜è¶³å¤Ÿè¿‘ï¼ˆgameWidthçš„ä¸€åŠï¼‰ï¼Œç”Ÿæˆæ›´å¤šå±±è„‰
    if (playerDistanceToRightEdge < gameWidth * 0.5) {
        // ä¸ºè¿œå¤„çš„å±±è„‰ç”Ÿæˆæ›´å¤š
        generateMoreMountains();
        
        // ä¸ºè¿‘å¤„çš„å°å±±ä¸˜ç”Ÿæˆæ›´å¤š
        generateMoreHills();
    }
    
    // å†…å­˜ä¼˜åŒ–ï¼šæ¸…ç†è¿œå¤„çš„å±±è„‰
    cleanUpDistantMountains();
}

// æ–°å¢å‡½æ•°ï¼šç”Ÿæˆæ›´å¤šè¿œå¤„å±±è„‰
function generateMoreMountains() {
    // è®¡ç®—éœ€è¦ç”Ÿæˆåˆ°çš„ä½ç½® - ç©å®¶è§†ç‚¹å‰æ–¹ä¸€æ®µè·ç¦»
    const targetX = camera.x + gameWidth * 3; 
    
    // åªåœ¨éœ€è¦æ—¶ç”Ÿæˆæ–°çš„å±±è„‰
    if (farthestMountainGenerated < targetX) {
        // ä»ä¸Šæ¬¡ç”Ÿæˆä½ç½®ç»§ç»­
        let mountainX = farthestMountainGenerated;
        
        // ä¸€ç›´ç”Ÿæˆåˆ°ç›®æ ‡ä½ç½®
        while (mountainX < targetX) {
            if (Math.random() > 0.4) { // 60%å‡ ç‡ç”Ÿæˆå±±è„‰
                mountainPositions.push({
                    x: mountainX,
                    height: 60 + Math.random() * 60,
                    seed: Math.random()
                });
            }
            mountainX += 600 + Math.random() * 800; // å±±è„‰é—´è·
        }
        
        // æ›´æ–°æœ€è¿œç”Ÿæˆä½ç½®
        farthestMountainGenerated = mountainX;
    }
}

// æ–°å¢å‡½æ•°ï¼šç”Ÿæˆæ›´å¤šè¿‘å¤„å°å±±ä¸˜
function generateMoreHills() {
    // è®¡ç®—éœ€è¦ç”Ÿæˆåˆ°çš„ä½ç½® - ç©å®¶è§†ç‚¹å‰æ–¹ä¸€æ®µè·ç¦»
    const targetX = camera.x + gameWidth * 3;
    
    // åªåœ¨éœ€è¦æ—¶ç”Ÿæˆæ–°çš„å°å±±ä¸˜
    if (farthestHillGenerated < targetX) {
        // ä»ä¸Šæ¬¡ç”Ÿæˆä½ç½®ç»§ç»­
        let hillX = farthestHillGenerated;
        
        // ä¸€ç›´ç”Ÿæˆåˆ°ç›®æ ‡ä½ç½®
        while (hillX < targetX) {
            if (Math.random() > 0.3) { // 70%å‡ ç‡ç”Ÿæˆå°å±±ä¸˜
                hillPositions.push({
                    x: hillX,
                    height: 30 + Math.random() * 25,
                    seed: Math.random()
                });
            }
            hillX += 300 + Math.random() * 400; // å°å±±ä¸˜é—´è·
        }
        
        // æ›´æ–°æœ€è¿œç”Ÿæˆä½ç½®
        farthestHillGenerated = hillX;
    }
}

// æ–°å¢å‡½æ•°ï¼šæ¸…ç†è¿œå¤„å±±è„‰
function cleanUpDistantMountains() {
    // åªæœ‰å½“å±±è„‰æ•°é‡è¶…è¿‡ä¸€å®šé˜ˆå€¼æ‰æ¸…ç†
    if (mountainPositions.length > 300) {
        const cleanupDistance = camera.x - gameWidth * 10; // éå¸¸è¿œçš„è·ç¦»æ‰æ¸…ç†
        
        // ç§»é™¤è¿œå¤„çš„å±±è„‰
        mountainPositions = mountainPositions.filter(mountain => mountain.x > cleanupDistance);
    }
    
    // åŒæ ·æ¸…ç†å°å±±ä¸˜
    if (hillPositions.length > 400) {
        const cleanupDistance = camera.x - gameWidth * 8; // éå¸¸è¿œçš„è·ç¦»æ‰æ¸…ç†
        
        // ç§»é™¤è¿œå¤„çš„å°å±±ä¸˜
        hillPositions = hillPositions.filter(hill => hill.x > cleanupDistance);
    }
}

        
        // æ›´æ–°è¿›åº¦æ¡
        function updateProgressBar() {
            // æ›´æ–°å·¦ä¸Šè§’å•è¯è¿›åº¦æ˜¾ç¤º
            document.getElementById('score').textContent = `å•è¯: ${visibleWordIndex + 1} / ${wordList.length}`;
            
            // æ›´æ–°è¿›åº¦æ¡å¡«å……
            const progressPercentage = (visibleWordIndex / (wordList.length - 1)) * 100;
            document.getElementById('progressFill').style.width = progressPercentage + '%';
        }
        
        // æ£€æŸ¥ç©å®¶ä¸å•è¯å¯¹è±¡çš„äº¤äº’ - å¸¦æœ‰èƒŒè¯µæ¨¡å¼æ”¯æŒ
        function checkWordInteraction() {
            let currentVisibleIndex = -1;
            
            for (let i = 0; i < gameObjects.length; i++) {
                const obj = gameObjects[i];
                
                if (obj.word) {
                    // è®¡ç®—ç©å®¶å’Œå•è¯å¯¹è±¡ä¹‹é—´çš„è·ç¦»
                    const dx = (player.x + player.width / 2) - (obj.x + obj.width / 2);
                    const dy = (player.y + player.height / 2) - (obj.y + obj.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // æ£€æŸ¥å½“å‰çœ‹åˆ°çš„å•è¯ç´¢å¼•
                    if (distance < 300 && obj.word.index > currentVisibleIndex) {
                        currentVisibleIndex = obj.word.index;
                    }
                    
                    // å¦‚æœè·ç¦»å°äº150ï¼Œæ ¹æ®èƒŒè¯µæ¨¡å¼å†³å®šæ˜¾ç¤ºæç¤ºæˆ–ç›´æ¥æ˜¾ç¤ºé‡Šä¹‰
                    if (distance < 150) {
                        if (studyMode) {
                            // èƒŒè¯µæ¨¡å¼ï¼šæ˜¾ç¤ºæç¤ºæŒ‰é’®ï¼Œéœ€è¦ç‚¹å‡»æ‰æ˜¾ç¤ºé‡Šä¹‰
                            if (!obj.hintShown) {
                                showHintButton(obj);
                                obj.hintShown = true;
                            }
                        } else {
                            // æ™®é€šæ¨¡å¼ï¼šç›´æ¥æ˜¾ç¤ºé‡Šä¹‰å’ŒéŸ³é‡æŒ‰é’®
                            if (!obj.translationVisible) {
                                obj.translationVisible = true;
                                
                                // æ˜¾ç¤ºéŸ³é‡å›¾æ ‡
                                showVolumeIcon(obj);
                                
                                // æ˜¾ç¤ºå•è¯é‡Šä¹‰
                                showWordTranslation(obj);
                                
                                // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ¥è§¦ï¼Œæ›´æ–°åˆ†æ•°
                                if (!obj.visited) {
                                    obj.visited = true;
                                    score++;
                                    
                                    // æ›´æ–°å½“å‰æœ€è¿œå•è¯ç´¢å¼•ï¼ˆä»…å½“æ›´è¿œæ—¶ï¼‰
                                    if (obj.word.index > currentWordIndex) {
                                        currentWordIndex = obj.word.index;
                                    }
                                }
                            }
                        }
                    } else {
                        // è·ç¦»å˜è¿œåï¼Œæ ‡è®°ä¸ºéšè—ï¼Œè¿™æ ·å†æ¬¡æ¥è¿‘æ—¶å¯ä»¥å†æ˜¾ç¤º
                        obj.translationVisible = false;
                        obj.hintShown = false;
                    }
                }
            }
            
            // æ›´æ–°å½“å‰å¯è§å•è¯ç´¢å¼•
            if (currentVisibleIndex >= 0) {
                visibleWordIndex = currentVisibleIndex;
                updateProgressBar();
            }
        }
        
        // æ˜¾ç¤ºæç¤ºæŒ‰é’® - èƒŒè¯µæ¨¡å¼ä¸“ç”¨
        function showHintButton(wordObj) {
            const hintButton = document.getElementById('hintButton');
            
            // å®šä½æç¤ºæŒ‰é’®åœ¨å±å¹•ä¸Šçš„ä½ç½®ï¼Œæ”¾åœ¨å•è¯æ­£ä¸Šæ–¹
            const buttonX = wordObj.x - camera.x + wordObj.width / 2 - 20;
            const buttonY = wordObj.y - camera.y - 50;
            
            hintButton.style.left = buttonX + 'px';
            hintButton.style.top = buttonY + 'px';
            hintButton.style.display = 'flex';
            
            // å­˜å‚¨å½“å‰å•è¯
            activeHintButton = {
                wordObj: wordObj,
                element: hintButton
            };
            
            // ç‚¹å‡»äº‹ä»¶
            hintButton.onclick = function() {
                // æ˜¾ç¤ºå•è¯é‡Šä¹‰å’Œå‘éŸ³
                wordObj.translationVisible = true;
                showVolumeIcon(wordObj);
                showWordTranslation(wordObj);
                
                // è®°å½•æç¤ºæ¬¡æ•°
                addWordToHinted(wordObj.word);
                
                // éšè—æç¤ºæŒ‰é’®
                hintButton.style.display = 'none';
                activeHintButton = null;
            };
        }
        
        // æ˜¾ç¤ºéŸ³é‡å›¾æ ‡
        function showVolumeIcon(wordObj) {
            const volumeIcon = document.getElementById('volumeIcon');
            
            // å®šä½éŸ³é‡å›¾æ ‡åœ¨å±å¹•ä¸Šçš„ä½ç½®ï¼Œæ”¾åœ¨å•è¯æ—è¾¹è€Œä¸æ˜¯ä¸Šæ–¹
            const iconX = wordObj.x - camera.x + wordObj.width + 20;
            const iconY = wordObj.y - camera.y;
            
            volumeIcon.style.left = iconX + 'px';
            volumeIcon.style.top = iconY + 'px';
            volumeIcon.style.display = 'flex';
            
            // å­˜å‚¨å½“å‰å•è¯
            activeVolumeIcon = {
                word: wordObj.word.english,
                element: volumeIcon
            };
            
            // ç‚¹å‡»äº‹ä»¶
            volumeIcon.onclick = function() {
                speakWord(wordObj.word.english);
            };
            
            // è‡ªåŠ¨å‘éŸ³
            speakWord(wordObj.word.english);
        }
        
        // æœ—è¯»å•è¯
        function speakWord(word) {
            const speech = new SpeechSynthesisUtterance(word);
            speech.lang = 'en-US';
            window.speechSynthesis.speak(speech);
        }
        
        // æ˜¾ç¤ºå•è¯é‡Šä¹‰ - æ”¹è¿›å¯¹é½å’Œæ ·å¼
        function showWordTranslation(wordObj) {
            // å¦‚æœå·²ç»æœ‰è¯¥å•è¯çš„é‡Šä¹‰æ­£åœ¨æ˜¾ç¤ºï¼Œä¸è¦é‡å¤åˆ›å»º
            for (let i = 0; i < gameObjects.length; i++) {
                if (gameObjects[i].isTranslationFor && gameObjects[i].isTranslationFor === wordObj) {
                    return;
                }
            }
            
            // å•è¯ç¿»è¯‘æ˜¾ç¤ºåœ¨å•è¯ä¸‹æ–¹ä½ç½®
            const x = wordObj.x + wordObj.width / 2;
            const y = wordObj.y + wordObj.height + 30;
            
            const translation = {
                x: x,
                y: y,
                isTranslationFor: wordObj,
                opacity: 1.0,
                text: wordObj.isEnglishDisplay ? wordObj.word.chinese : wordObj.word.english,
                partOfSpeech: wordObj.word.partOfSpeech,
                color: wordObj.isEnglishDisplay ? '#ff9a3c' : '#4cc9f0',
                update: function() {
                    // ä¿æŒä½ç½®ç›¸å¯¹äºå•è¯
                    this.x = wordObj.x + wordObj.width / 2;
                    this.y = wordObj.y + wordObj.height + 30;
                    
                    // åªæœ‰å½“translationVisibleå˜ä¸ºfalseæ—¶æ‰æ·¡å‡º
                    if (!wordObj.translationVisible) {
                        this.opacity -= 0.05;
                        if (this.opacity <= 0) {
                            return false;
                        }
                    } else {
                        this.opacity = Math.min(1.0, this.opacity + 0.1);
                    }
                    return true;
                },
                draw: function(ctx) {
                    if (this.opacity <= 0) return;
                    
                    // ç»˜åˆ¶å¸¦æœ‰ä¸åŒèƒŒæ™¯è‰²çš„å•è¯ç¿»è¯‘å’Œè¯æ€§
                    ctx.font = 'bold 18px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // èƒŒæ™¯
                    const text = this.text;
                    const partOfSpeech = this.partOfSpeech;
                    
                    const textWidth = ctx.measureText(text).width;
                    const posWidth = partOfSpeech ? ctx.measureText(partOfSpeech).width : 0;
                    const maxWidth = Math.max(textWidth, posWidth);
                    const padding = 10;
                    
                    // è®¡ç®—èƒŒæ™¯é«˜åº¦ - æ ¹æ®æ˜¯å¦æœ‰è¯æ€§åŠ¨æ€è°ƒæ•´
                    const lineHeight = 24; // å•è¡Œæ–‡æœ¬é«˜åº¦
                    const bgHeight = partOfSpeech ? lineHeight * 2 + padding * 2 : lineHeight + padding * 2;
                    
                    // ç»˜åˆ¶ç¿»è¯‘èƒŒæ™¯
                    ctx.fillStyle = `rgba(0, 0, 0, ${this.opacity * 0.7})`;
                    ctx.fillRect(
                        this.x - maxWidth/2 - padding, 
                        this.y - bgHeight/2, 
                        maxWidth + padding * 2, 
                        bgHeight
                    );
                    
                    // ç»˜åˆ¶ç¿»è¯‘æ–‡æœ¬
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                    
                    if (partOfSpeech) {
                        // æœ‰è¯æ€§æ—¶ï¼Œæ˜¾ç¤ºåœ¨ä¸¤è¡Œï¼Œä¿æŒå‚ç›´å±…ä¸­
                        const textY = this.y - lineHeight/2;
                        const posY = this.y + lineHeight/2;
                        
                        ctx.fillText(text, this.x, textY);
                        
                        // ç»˜åˆ¶è¯æ€§
                        ctx.font = 'italic 14px Arial';
                        ctx.fillStyle = `rgba(200, 200, 200, ${this.opacity})`;
                        ctx.fillText(partOfSpeech, this.x, posY);
                    } else {
                        // æ— è¯æ€§æ—¶ï¼Œåªç»˜åˆ¶ç¿»è¯‘ï¼Œå‚ç›´å±…ä¸­
                        ctx.fillText(text, this.x, this.y);
                    }
                }
            };
            
            gameObjects.push(translation);
        }
        
        // æ–°æ·»åŠ çš„å‡½æ•°ï¼šç»˜åˆ¶æ‰€æœ‰å•è¯æ–‡æœ¬ï¼Œç¡®ä¿å®ƒä»¬æ˜¾ç¤ºåœ¨æœ€å‰é¢
        function drawWordTexts(ctx) {
            for (let i = 0; i < gameObjects.length; i++) {
                const obj = gameObjects[i];
                
                // åªå¤„ç†æœ‰å•è¯çš„å¯¹è±¡ä¸”åœ¨è§†é‡å†…
                if (obj.word && 
                    obj.x + (obj.width || 0) > camera.x && 
                    obj.x < camera.x + camera.width &&
                    obj.y + (obj.height || 0) > camera.y && 
                    obj.y < camera.y + camera.height) {
                    
                    // ç»˜åˆ¶å•è¯æ–‡æœ¬
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = 'white';
                    
                    const text = obj.isEnglishDisplay ? obj.word.english : obj.word.chinese;
                    ctx.fillText(text, obj.x + obj.width / 2, obj.y + obj.height / 2);
                }
            }
        }
        // ç»˜åˆ¶è§’è‰²
        function drawPlayer(ctx) {
            // ä¿å­˜å½“å‰ç»˜å›¾çŠ¶æ€
            ctx.save();
            
            // å¦‚æœè§’è‰²å‘å·¦ç§»åŠ¨ï¼Œæ°´å¹³ç¿»è½¬
            if (player.isMovingLeft) {
                ctx.translate(player.x + player.width, player.y);
                ctx.scale(-1, 1);
                ctx.translate(-player.width, 0);
            } else {
                ctx.translate(player.x, player.y);
            }
            
            // è®¾ç½®ç²—çº¿æ¡
            ctx.strokeStyle = player.outlineColor;
            ctx.lineWidth = player.outlineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // æ ¹æ®é€‰æ‹©çš„è§’è‰²ç»˜åˆ¶ä¸åŒçš„å½¢çŠ¶
            switch (selectedCharacter) {
                case 'stickman':
                    drawStickman(ctx);
                    break;
                    
                case 'ninja':
                    drawNinja(ctx);
                    break;
                    
                case 'robot':
                    drawRobot(ctx);
                    break;
            }
            
            // æ¢å¤ç»˜å›¾çŠ¶æ€
            ctx.restore();
        }
        
        // ç»˜åˆ¶ç«æŸ´äºº
        function drawStickman(ctx) {
            // è®¡ç®—åŠ¨ç”»å¸§
            const jumpOffset = player.isJumping ? -3 : 0;
            const bobbleOffset = player.isJumping ? 0 : Math.sin(player.frameCount * 0.2) * 2;
            
            // å¤´éƒ¨
            ctx.beginPath();
            ctx.arc(player.width / 2, 15, 12, 0, Math.PI * 2);
            ctx.stroke();
            
            // èº«ä½“
            ctx.beginPath();
            ctx.moveTo(player.width / 2, 27);
            ctx.lineTo(player.width / 2, 55);
            ctx.stroke();
            
            // æ‰‹è‡‚
            if (player.isJumping) {
                // è·³è·ƒæ—¶æ‰‹è‡‚ä¸Šä¸¾
                ctx.beginPath();
                ctx.moveTo(player.width / 2, 35);
                ctx.lineTo(player.width / 2 - 15, 25 + jumpOffset);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(player.width / 2, 35);
                ctx.lineTo(player.width / 2 + 15, 25 + jumpOffset);
                ctx.stroke();
            } else {
                // èµ°è·¯æ—¶æ‰‹è‡‚æ‘†åŠ¨
                ctx.beginPath();
                ctx.moveTo(player.width / 2, 35);
                ctx.lineTo(player.width / 2 - 15, 40 + Math.sin(player.frameCount * 0.2) * 5);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(player.width / 2, 35);
                ctx.lineTo(player.width / 2 + 15, 40 + Math.sin(player.frameCount * 0.2 + Math.PI) * 5);
                ctx.stroke();
            }
            
            // è…¿éƒ¨
            ctx.beginPath();
            ctx.moveTo(player.width / 2, 55);
            ctx.lineTo(player.width / 2 - 10, 75 + bobbleOffset);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(player.width / 2, 55);
            ctx.lineTo(player.width / 2 + 10, 75 + Math.sin(player.frameCount * 0.2 + Math.PI) * 2);
            ctx.stroke();
        }
        
        // ç»˜åˆ¶å¿è€…
        function drawNinja(ctx) {
            // è®¡ç®—åŠ¨ç”»å¸§
            const jumpOffset = player.isJumping ? -3 : 0;
            const bobbleOffset = player.isJumping ? 0 : Math.sin(player.frameCount * 0.2) * 2;
            
            // å¤´éƒ¨
            ctx.beginPath();
            ctx.arc(player.width / 2, 15, 12, 0, Math.PI * 2);
            ctx.stroke();
            
            // å¿è€…å¤´å¸¦
            ctx.beginPath();
            ctx.moveTo(player.width / 2 - 14, 15);
            ctx.lineTo(player.width / 2 + 14, 15);
            ctx.stroke();
            
            // èº«ä½“
            ctx.beginPath();
            ctx.moveTo(player.width / 2, 27);
            ctx.lineTo(player.width / 2, 55);
            ctx.stroke();
            
            // æ‰‹è‡‚
            if (player.isJumping) {
                // è·³è·ƒæ—¶æ‰‹åŠ¿ä¸åŒ
                ctx.beginPath();
                ctx.moveTo(player.width / 2, 35);
                ctx.lineTo(player.width / 2 - 15, 30 + jumpOffset);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(player.width / 2, 35);
                ctx.lineTo(player.width / 2 + 15, 30 + jumpOffset);
                ctx.stroke();
            } else {
                // å¿è€…è·‘æ­¥å§¿åŠ¿
                ctx.beginPath();
                ctx.moveTo(player.width / 2, 35);
                ctx.lineTo(player.width / 2 - 18, 30 + Math.sin(player.frameCount * 0.3) * 8);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(player.width / 2, 35);
                ctx.lineTo(player.width / 2 + 18, 30 + Math.sin(player.frameCount * 0.3 + Math.PI) * 8);
                ctx.stroke();
            }
            
            // è…¿éƒ¨
            ctx.beginPath();
            ctx.moveTo(player.width / 2, 55);
            ctx.lineTo(player.width / 2 - 12, 75 + bobbleOffset);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(player.width / 2, 55);
            ctx.lineTo(player.width / 2 + 12, 75 + Math.sin(player.frameCount * 0.2 + Math.PI) * 2);
            ctx.stroke();
        }
        
        // ç»˜åˆ¶æœºå™¨äºº
        function drawRobot(ctx) {
            const bobbleOffset = player.isJumping ? 0 : Math.sin(player.frameCount * 0.2) * 1;
            
            // å¤´éƒ¨
            ctx.strokeRect(player.width / 2 - 10, 5, 20, 15);
            
            // çœ¼ç›
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(player.width / 2 - 5, 12, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(player.width / 2 + 5, 12, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // èº«ä½“
            ctx.strokeRect(player.width / 2 - 15, 20, 30, 30);
            
            // æ§åˆ¶é¢æ¿
            ctx.beginPath();
            ctx.moveTo(player.width / 2 - 10, 35);
            ctx.lineTo(player.width / 2 + 10, 35);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(player.width / 2 - 10, 40);
            ctx.lineTo(player.width / 2 + 10, 40);
            ctx.stroke();
            
            // æ‰‹è‡‚
            if (player.isJumping) {
                // è·³è·ƒæ—¶æ‰‹è‡‚ä¸Šä¸¾
                ctx.strokeRect(player.width / 2 - 22, 20, 7, 15);
                ctx.strokeRect(player.width / 2 + 15, 20, 7, 15);
            } else {
                // èµ°è·¯æ—¶æ‰‹è‡‚æ‘†åŠ¨
                ctx.strokeRect(player.width / 2 - 22, 25 + Math.sin(player.frameCount * 0.2) * 5, 7, 15);
                ctx.strokeRect(player.width / 2 + 15, 25 + Math.sin(player.frameCount * 0.2 + Math.PI) * 5, 7, 15);
            }
            
            // è…¿éƒ¨
            ctx.strokeRect(player.width / 2 - 12, 50, 8, 25 + bobbleOffset);
            ctx.strokeRect(player.width / 2 + 4, 50, 8, 25 + Math.sin(player.frameCount * 0.2 + Math.PI) * 1);
        }
        
        // æ›´æ–°ç©å®¶çŠ¶æ€
        function updatePlayer(deltaTime) {
            // é‡åŠ›
            player.velY += 0.7;
            
            // æ°´å¹³ç§»åŠ¨
            player.isMovingLeft = false;
            player.isMovingRight = false;
            // æ·»åŠ è¿™ä¸ªåˆ¤æ–­ï¼šå¦‚æœç©å®¶åœ¨èµ·å§‹ä½ç½®é™„è¿‘ï¼Œç¦æ­¢å‘å·¦ç§»åŠ¨
            const isNearStart = player.x < 20;
            
            if (isMobile) {
                // æ‰‹æœºæ§åˆ¶
                if (joystickActive) {
                    const joystickX = Math.cos(joystickAngle);
                    
                    if (joystickX < -0.3 && !isNearStart) {
                        player.x -= player.speed;
                        player.isMovingLeft = true;
                    } else if (joystickX > 0.3) {
                        player.x += player.speed;
                        player.isMovingRight = true;
                    }
                }
            } else {
                // é”®ç›˜æ§åˆ¶
                if ((keys['ArrowLeft'] || keys['a']) && !isNearStart) {
                    player.x -= player.speed;
                    player.isMovingLeft = true;
                }
                
                if (keys['ArrowRight'] || keys['d']) {
                    player.x += player.speed;
                    player.isMovingRight = true;
                }
            }
            
            // åº”ç”¨å‚ç›´é€Ÿåº¦
            player.y += player.velY;
            
            // ç¢°æ’æ£€æµ‹
            let onGround = false;
            
            // é¦–å…ˆæ£€æŸ¥å¸¸è§„å¹³å°
            for (let i = 0; i < platforms.length; i++) {
                const platform = platforms[i];
                
                if (player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {
                    
                    // æ£€æŸ¥é¡¶éƒ¨ç¢°æ’
                    if (player.velY > 0 && player.y + player.height < platform.y + platform.height/2) {
                        player.y = platform.y - player.height;
                        player.velY = 0;
                        onGround = true;
                    }
                }
            }
            
            // ç„¶åæ£€æŸ¥ç‰¹æ®Šå¹³å°ï¼ˆæ¯”å¦‚è—¤è”“ï¼‰
            if (window.specialPlatforms) {
                for (let i = 0; i < window.specialPlatforms.length; i++) {
                    const platform = window.specialPlatforms[i];
                    
                    if (platform.platformCheck && platform.platformCheck(player)) {
                        if (player.velY > 0) {
                            player.velY = 0;
                            onGround = true;
                        }
                    }
                }
            }
            
            // æ£€æŸ¥è·³æ¿ - è·³æ¿ä¸å†æ¶ˆå¤±ï¼Œå¯ä»¥å¤šæ¬¡ä½¿ç”¨
            for (let i = 0; i < jumpboards.length; i++) {
                if (jumpboards[i].checkInteraction) {
                    jumpboards[i].checkInteraction(player);
                }
            }
            
            // æ£€æŸ¥å±é™©åŒºåŸŸï¼ˆå¦‚å°–åˆºã€è†æ£˜ï¼‰
            if (window.hazards) {
                for (let i = 0; i < window.hazards.length; i++) {
                    const hazard = window.hazards[i];
                    if (hazard.checkHazard && hazard.checkHazard(player)) {
                        // å±é™©åŒºåŸŸå¤„ç†å·²åœ¨checkHazardå†…å®Œæˆ
                    }
                }
            }
            
            // é‡ç½®è·³è·ƒçŠ¶æ€
            if (onGround) {
                player.isJumping = false;
            }
            
            // é˜²æ­¢æ‰å‡ºä¸–ç•Œ - ç°åœ¨ä¸ä¼šæ‰è½åˆ°æœ€ä¸‹é¢
            if (player.y > gameHeight * 2) {
                // ä¼ é€å›æœ€è¿‘çš„å¹³å°ä¸Š
                let nearestPlatform = null;
                let shortestDistance = Infinity;
                
                for (let i = 0; i < platforms.length; i++) {
                    const platform = platforms[i];
                    if (Math.abs(platform.x - player.x) < shortestDistance && 
                        platform.y < gameHeight) { // ç¡®ä¿å¹³å°åœ¨æ¸¸æˆåŒºåŸŸå†…
                        shortestDistance = Math.abs(platform.x - player.x);
                        nearestPlatform = platform;
                    }
                }
                
                if (nearestPlatform) {
                    player.x = nearestPlatform.x + nearestPlatform.width / 2 - player.width / 2;
                    player.y = nearestPlatform.y - player.height;
                } else {
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°é™„è¿‘çš„å¹³å°ï¼Œå›åˆ°èµ·ç‚¹
                    player.x = 100;
                    player.y = gameHeight / 2;
                }
                
                player.velY = 0;
            }
            
            // æ›´æ–°å¸§åŠ¨ç”»è®¡æ•°å™¨
            player.frameCount++;
            
            // æ£€æŸ¥å•è¯äº¤äº’
            checkWordInteraction();
        }
        
        // æ›´æ–°ç›¸æœºä½ç½®
        function updateCamera() {
            // æ°´å¹³è·Ÿéšç©å®¶
            if (player.x < camera.leftEdge()) {
                camera.x = player.x - (camera.width * 0.25);
            } else if (player.x + player.width > camera.rightEdge()) {
                camera.x = player.x + player.width - (camera.width * 0.75);
            }
            
            // å‚ç›´è·Ÿéšç©å®¶ - å…è®¸åœ°ä¸‹æ¢ç´¢
            if (player.y < camera.topEdge()) {
                camera.y = player.y - (camera.height * 0.25);
            } else if (player.y + player.height > camera.bottomEdge()) {
                camera.y = player.y + player.height - (camera.height * 0.75);
            }
            
            // é™åˆ¶ç›¸æœºä¸è¦ç§»åŠ¨åˆ°ä¸–ç•Œè¾¹ç•Œå¤–
            camera.x = Math.max(0, camera.x);
            // ä¸å†é™åˆ¶ç›¸æœºYè½´ï¼Œå…è®¸åœ°ä¸‹æ¢ç´¢
            // camera.y = Math.max(0, camera.y);
        }
        
        // ç»˜åˆ¶æ¸¸æˆ - ä¿®æ”¹åçš„ç‰ˆæœ¬ï¼Œå¢åŠ drawWordTextså‡½æ•°è°ƒç”¨
        function drawGame() {
            // æ¸…é™¤ç”»å¸ƒ
            ctx.clearRect(0, 0, gameWidth, gameHeight);
            
            // å…ˆç»˜åˆ¶é™æ€èƒŒæ™¯
            drawGameBackground(ctx);
            
            // ä¿å­˜å½“å‰å˜æ¢
            ctx.save();
            
            // åº”ç”¨ç›¸æœºå˜æ¢
            ctx.translate(-camera.x, -camera.y);
            
            // ç»˜åˆ¶åŠ¨æ€èƒŒæ™¯
            for (let i = 0; i < backgrounds.length; i++) {
                backgrounds[i].draw(ctx);
            }
            
            // ç»˜åˆ¶å¹³å°
            for (let i = 0; i < platforms.length; i++) {
                const platform = platforms[i];
                
                // åªç»˜åˆ¶è§†é‡å†…çš„ç‰©ä½“
                if (platform.x + platform.width > camera.x && 
                    platform.x < camera.x + camera.width &&
                    platform.y + platform.height > camera.y && 
                    platform.y < camera.y + camera.height) {
                    
                    if (platform.draw) {
                        platform.draw(ctx);
                    } else {
                        ctx.fillStyle = platform.color || getSeasonColor('ground');
                        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    }
                }
            }
            
            // ç»˜åˆ¶æ¸¸æˆå¯¹è±¡
            for (let i = 0; i < gameObjects.length; i++) {
                const obj = gameObjects[i];
                
                // åªç»˜åˆ¶è§†é‡å†…çš„ç‰©ä½“
                if (obj.x + (obj.width || 0) > camera.x && 
                    obj.x < camera.x + camera.width &&
                    obj.y + (obj.height || 0) > camera.y && 
                    obj.y < camera.y + camera.height) {
                    
                    if (obj.draw) {
                        obj.draw(ctx);
                    } else if (obj.type === 'finish') {
                        // ç»˜åˆ¶ç»ˆç‚¹æ——å¸œ
                        ctx.fillStyle = '#ff5733';
                        ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                        
                        ctx.fillStyle = 'white';
                        for (let j = 0; j < 4; j++) {
                            ctx.fillRect(obj.x, obj.y + j * 40, obj.width, 20);
                        }
                    }
                }
            }
                // ç»˜åˆ¶é¸Ÿç±»
            for (let i = 0; i < birds.length; i++) {
                const bird = birds[i];
                
                if (bird.x + bird.width > camera.x && 
                    bird.x < camera.x + camera.width &&
                    bird.y + bird.height > camera.y && 
                    bird.y < camera.y + camera.height) {
                    
                    if (bird.draw) {
                        bird.draw(ctx);
                    }
                }
            }
            
            // ç»˜åˆ¶ç‰¹æ®Šå¹³å°ï¼ˆæ¯”å¦‚è—¤è”“ï¼‰å’Œè·³æ¿
            if (window.specialPlatforms) {
                for (let i = 0; i < window.specialPlatforms.length; i++) {
                    const platform = window.specialPlatforms[i];
                    
                    if (platform.draw && 
                        platform.x + platform.width > camera.x && 
                        platform.x < camera.x + camera.width &&
                        platform.y + platform.height > camera.y && 
                        platform.y < camera.y + camera.height) {
                        
                        platform.draw(ctx);
                    }
                }
            }
            
            // ç»˜åˆ¶ç©å®¶
            drawPlayer(ctx);
            
            // åœ¨æœ€åç»˜åˆ¶æ‰€æœ‰å•è¯æ–‡æœ¬ï¼Œç¡®ä¿å®ƒä»¬æ˜¾ç¤ºåœ¨é¡¶å±‚
            drawWordTexts(ctx);
            
            // æ¢å¤å˜æ¢
            ctx.restore();
        }
        
        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function updateGame(deltaTime) {
            // æ›´æ–°ç©å®¶
            updatePlayer(deltaTime);
            
            // æ›´æ–°ç›¸æœº
            updateCamera();
            // æ£€æŸ¥å¹¶ç”Ÿæˆå±±è„‰
            checkAndGenerateMountains();
          // æ›´æ–°æ¸¸æˆå¯¹è±¡
for (let i = gameObjects.length - 1; i >= 0; i--) {
    const obj = gameObjects[i];
    
    if (obj.update) {
        const active = obj.update(deltaTime);
        // åªæœ‰å½“activeæ˜ç¡®ä¸ºfalseä¸”å¯¹è±¡ä¸æ˜¯è·³æ¿æ—¶æ‰ç§»é™¤
        if (active === false && obj.type !== 'jumpboard') {
            gameObjects.splice(i, 1);
        }
    }
    
    // å¦‚æœå¯¹è±¡æ˜¯åŠ¨æ€çš„ï¼ˆå¦‚èƒèŸ¹ï¼‰ï¼Œæ›´æ–°å…¶è¡Œä¸º
    if (obj.updateBehavior) {
        obj.updateBehavior(deltaTime);
    }
}
            
            // æ›´æ–°ç¯å¢ƒæ•ˆæœ
            updateEnvironment(deltaTime);
        }
        
        // æ¸¸æˆå¾ªç¯
        function gameLoop(timestamp) {
            // è®¡ç®—æ—¶é—´å¢é‡
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // æ›´æ–°æ¸¸æˆæ—¶é—´
            gameTime += deltaTime;
            
            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            updateGame(deltaTime);
               updateDucks(deltaTime);
            
            // ç»˜åˆ¶æ¸¸æˆ
            drawGame();
            
            // å¦‚æœéŸ³é‡å›¾æ ‡æ˜¯æ´»è·ƒçš„ï¼Œæ›´æ–°å®ƒçš„ä½ç½®
            if (activeVolumeIcon) {
                for (let i = 0; i < gameObjects.length; i++) {
                    const obj = gameObjects[i];
                    if (obj.word && obj.word.english === activeVolumeIcon.word) {
                        // æ”¾åœ¨å•è¯æ—è¾¹
                        const iconX = obj.x - camera.x + obj.width + 20;
                        const iconY = obj.y - camera.y;
                        
                        activeVolumeIcon.element.style.left = iconX + 'px';
                        activeVolumeIcon.element.style.top = iconY + 'px';
                        break;
                    }
                }
            }
            
            // å¦‚æœæç¤ºæŒ‰é’®æ˜¯æ´»è·ƒçš„ï¼Œæ›´æ–°å®ƒçš„ä½ç½®
            if (activeHintButton) {
                const obj = activeHintButton.wordObj;
                const buttonX = obj.x - camera.x + obj.width / 2 - 20;
                const buttonY = obj.y - camera.y - 50;
                
                activeHintButton.element.style.left = buttonX + 'px';
                activeHintButton.element.style.top = buttonY + 'px';
            }
            
            // ç»§ç»­æ¸¸æˆå¾ªç¯
            if (gameRunning && !gamePaused) {
                animationId = requestAnimationFrame(gameLoop);
            }
            // åœ¨gameLoopå‡½æ•°æœ«å°¾æ·»åŠ updateDuckså‡½æ•°
function updateDucks(deltaTime) {
    // æ›´æ–°é¸­å­
    for (let i = 0; i < ducks.length; i++) {
        if (ducks[i].update) {
            ducks[i].update(deltaTime);
        }
    }
    
    // æ›´æ–°æ± å¡˜
    for (let i = 0; i < ponds.length; i++) {
        const pond = ponds[i];
        // ç§»é™¤æ— æ•ˆçš„é¸­å­ï¼Œå¦‚è¶…å‡ºå±å¹•å¤ªè¿œçš„é¸­å­
        for (let j = pond.ducks.length - 1; j >= 0; j--) {
            const duck = pond.ducks[j];
            // å¦‚æœé¸­å­ç¦»æ± å¡˜å¤ªè¿œï¼Œç§»é™¤å®ƒ
            if (Math.abs(duck.x - (pond.x + pond.width/2)) > pond.width * 1.5) {
                // ä»æ¸¸æˆå¯¹è±¡å’Œé¸­å­æ•°ç»„ä¸­ç§»é™¤
                const gameObjIndex = gameObjects.indexOf(duck);
                if (gameObjIndex !== -1) {
                    gameObjects.splice(gameObjIndex, 1);
                }
                
                const ducksIndex = ducks.indexOf(duck);
                if (ducksIndex !== -1) {
                    ducks.splice(ducksIndex, 1);
                }
                
                // ä»æ± å¡˜çš„é¸­å­æ•°ç»„ä¸­ç§»é™¤
                pond.ducks.splice(j, 1);
            }
        }
        // æ£€æŸ¥æ± å¡˜ä¸­çš„é¸­å­æ•°é‡ï¼Œå¦‚æœå¤ªå°‘å°±æ·»åŠ æ–°çš„
        if (pond.ducks.length < pond.maxDucks && Math.random() < 0.005) {
            // è®¡ç®—å®‰å…¨åŒºåŸŸï¼Œé¿å…é¸­å­é è¿‘è¾¹ç¼˜
            const safeMargin = 60;
            const safeLeft = pond.x + safeMargin;
            const safeRight = pond.x + pond.width - safeMargin;
            
            // ç¡®ä¿é¸­å­åœ¨å®‰å…¨åŒºåŸŸå†…
            const duckX = safeLeft + Math.random() * (safeRight - safeLeft);
            const newDuck = createDuck(duckX, pond.y - 10);
            pond.ducks.push(newDuck);
        }
    }
}
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        initGame();
    </script>
</body>
</html>